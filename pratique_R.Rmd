---
title: "Guide pratique R"
author: "Christophe Fouchard"
date: "`r format(Sys.Date(),format = '%d/%m/%Y')`"
output:
    # toc signifie "table of contents" (càd table des matières)
  #   html_document:
  rmdformats::readthedown:
    fig_width : 4
    fig_height : 3
    highlight : "kate"
    toc_depth : 3
    use_bookdown : TRUE
    theme: united
    css: styles.css
  #   df_print: tibble
  #   fig_height: 2
  #   fig_width: 3
  #   fontfamily: mathpazo
  #   highlight: tango
  #   theme: lumen
     # toc: yes
     # toc_depth: 3
     # toc_float: yes
     # number_sections: true
  word_document:
    toc: yes
  pdf_document:
    toc: yes
editor_options:
  chunk_output_type: console
---

<style>
  .left {
    text-align: left;
  }
  .right {
    text-align: right;
  }
  .center {
    text-align: center;
  }
</style>


<style type="text/css">

h1.title {
  color: SteelBlue;
}
h1 { /* Header 1 */
  color: SteelBlue;
}
h2 { /* Header 2 */
  color: SteelBlack;
}
h3 { /* Header 3 */
  color: SteelBlue;
}
h4 { /* Header 4 */
  color: SteelBlue;
}

h5 { /* Header 5 */
  color: SteelBlue;
}
</style>

<style>
.button {
  display: inline-block;
  border-radius: 4px;
  background-color: SteelBlue;
  border: none;
  color: #FFFFFF;
  text-align: center;
  font-size: 16px;
  transition: all 0.5s;
  cursor: pointer;
}

.button span {
  cursor: pointer;
  display: inline-block;
  position: relative;
  transition: 0.5s;
}

.button span:after {
  content: '\00bb';
  position: absolute;
  opacity: 0;
  top: 0;
  right: -20px;
  transition: 0.5s;
}

.button:hover span {
  padding-right: 25px;
}

.button:hover span:after {
  opacity: 1;
  right: 0;
}

.retour {
  float: right;
  }
</style>


```{r setup, include=FALSE}
library(knitr)
library(rmdformats)
## Global options
knitr::opts_chunk$set(cache = TRUE,
                      include = TRUE,
                      echo = TRUE,
                      eval=TRUE,
                      message = FALSE,
                      warning = FALSE,
                      results="hide",
                      fig.height=3, fig.width=4)
```


***

<br>

# Environnement

On trouvera ici l'environnement permettant de faire tourner des scripts R.

## Cerise

L'accès à R peut se réaliser via Cerise, la plateforme de stockage et de traitement des données.

### Version de R

La version de R par défaut est la 4.0.2. La version précédente (3.3.2) est toujours disponible.
Il est recommandé d'utiliser la nouvelle version de R.

Pour changer de version, aller en haut à droite et cocher la version souhaitée.

<center>![](images/Cerise_version_R.png)</center>

### Sessions R

Il est possible d'avoir plusieurs sessions R ouvertes.
On peut choisir la version de R utilisée au lancement de la session, en allant en haut à droite, via :

<center>![](images/Cerise_ouvrir_session_R.png){width=50%}</center>

puis choisir la version de R à travers la fenêtre :

<center>![](images/Cerise_nouvelle_session_R.png){width=50%}</center>


### Comment récupérer un chemin pour l'utiliser dans un programme R

Dans la fenêtre de parcours des dossiers (fenêtre en bas à droite dans RStudio Server), choisir More   
puis Set as Working Directory.

```{r}
# setwd("~/CERISE/01-Espace-de-Partage/SRISE/Pays-De-La-Loire/Partage_R")

```
Le chemin peut-être aussi copié depuis la console (fenêtre en bas à gauche).

### Comment se déplacer rapidement vers un autre répertoire

Pour l'utilisateur muni de ce chemin, il convient de cliquer sur les trois petits points (fenêtre en bas à droite dans RStudio Server)

Dans la fenêtre qui apparaît, on colle le chemin vers le dossier d'intérêt, par exemple  
~/CERISE/01-Espace-de-Partage/SRISE/Pays-De-La-Loire/Partage_R

~(AltGr+2) permet d'indiquer le répertoire racine dans Cerise.

On clique enfin sur OK, nous voici dans le bon dossier.

Pour vérifier le répertoire de travail, on peut exécuter `getwd()`

```{r, eval=FALSE} 
> setwd("~/CERISE")
> getwd()
# donne [1] "/var/data/gluster/volume0/CERISE"

```


### Comment créer un nouveau répertoire

Dans le cadran en bas à droite, aller dans le menu `Files`, choisir `New Folder`.


```{r, eval=FALSE} 
dir.create("nouveau_dossier")

```
### Comment créer un nouveau script R

Dans le menu `File`, choisir `New File`, `R script`


```{r, eval=FALSE} 
# création d'un .R :
file.create("nouveau_pgm.R")

```

### Comment copier un fichier ou un dossier via R

```{r, eval=FALSE} 
library(fs)
 
# pour les fichiers
# fs::file_copy("chemin/vers/le/fichier_a_copier.csv", "chemin/vers/le/dossier_cible/")
 
# pour les dossiers
# fs::dir_copy

## Exemple de copie d'un dossier ou d'un fichier via R

# pour les dossiers
chemin_path <- "~/CERISE/01-Espace-de-Partage/SRISE/Pays-De-La-Loire/Partage_R/"
entree_path1 <- "Christophe/entree"
entree_path2 <- "Christophe/pgm"
entree_path3 <- "Christophe/sortie"
sortie_path1 <- "temporaire"

fs::dir_copy(path=paste0(chemin_path,entree_path1),
             new_path=paste0(chemin_path,sortie_path1))
dir_copy(path=paste0(chemin_path,entree_path2),
         new_path=paste0(chemin_path,sortie_path1),
         overwrite = TRUE)
dir_copy(path=paste0(chemin_path,entree_path3),
         new_path=paste0(chemin_path,sortie_path1))

# pour les fichiers
# fs::file_copy("chemin/vers/le/fichier_a_copier.csv", "chemin/vers/le/dossier_cible/")
chemin_fichier_entree <- "~/CERISE/01-Espace-de-Partage/SRISE/Pays-De-La-Loire/Partage_R/Christophe/pgm/"
entree_fichier <- "manipulations.R"
chemin_fichier_sortie <- "~/CERISE/01-Espace-de-Partage/SRISE/Pays-De-La-Loire/Partage_R/temporaire/pgm/"

fs::file_copy(path=paste0(chemin_fichier_entree,entree_fichier),
              new_path=paste0(chemin_fichier_sortie),
              overwrite = TRUE)

# renommer un fichier grâce à la fonction file.rename() :
# file.rename(from = "nouveau_fichier.csv", to = "mon_fichier.csv")
# file.rename(from = "nouveau_pgm.R", to = "nouveau_pgm_2.R")

```
### Comment transférer des fichiers entre son poste de travail et Cerise

#### Comment télécharger un fichier depuis Cerise

Une fois sur l'interface Rstudio de Cerise, il faut naviguer vers le dossier contenant le fichier à traiter.

Pour cela, il faut utiliser le navigateur de fichier, dans la partie bas droite de l'écran.

Il faut naviguer dans les dossiers jusqu'au fichier et ensuite sélectionner celui-ci pour pouvoir le télécharger, puis aller dans More > Export

#### Comment téléverser un fichier vers Cerise

Dans le cas d'un fichier ayant vocation à  être déposé sur Cerise, il faut utiliser le navigateur de fichier de RStudio, dans la partie bas droite de l'écran.

Une fois placé dans le dossier de dépôt du fichier, choisir Upload.

Puis récupérer le fichier sur son poste de travail en utilisant Parcourir, puis OK.

#### Détails avec des captures d'écran
https://orion.agriculture/confluence/pages/viewpage.action?pageId=38601956

### Foire aux questions
https://orion.agriculture/confluence/display/CER/4+-+FAQ

## R Studio

L’interface RStudio est composée de différents panneaux, incluant une console, un navigateur de fichiers et graphiques, l’espace de travail et l’historique des commandes.

<center>![](images/interface_Rstudio.png)</center>

### Faire tourner des programmes via l'environnement de développement intégré `R Studio`

Exécution en interactif dans la session courante de l'utilisateur.

A partir du programme ouvert dans l'IDE Rstudio, l'utilisateur exécute le programme manuellement :

    Menu Code/ Run
    Bouton Run
    Combinaison de touche Ctrl-A suivie de Ctrl-Entrée

Une fois l'exécution commencée, la console présente à l'utilisateur les informations du déroulé du programme.

Dans ce mode, l'utilisateur doit attendre que le programme se termine pour à nouveau relancer un programme s'il souhaite rester dans la même session. Les objets de l'environnement d'exécution évoluent également tout au long du déroulé du programme exécuté, et les ressources de la session sont mobilisées par l'exécution courante.

### Raccourcis RStudio

Pour gagner du temps, il est important d'utiliser les raccourcis pour les commandes répétitives. 

    # (`AltGr` + `3`) pour commenter son code
    
    `Ctrl` + `Shift` + `M` : insère le pipe `%>%`
     Plusieurs verbes (ou fonctions) peuvent facilement être combinés  
     en utilisant l'opérateur `%>%` (pipe) qui permet d'enchaîner les instructions.
    Penser à aérer son code, notamment en revenant à la ligne, après un %>%
     x %>% 
      f %>% 
        g %>% 
          h  
    est équivalent à h(g(f(x)))

    `Alt` + `-` : insère la flèche d'assignation <- (il faut utiliser le - du pavé numérique, 
    pas celui du 6)
    `Alt`+ `6` (Windows) : insére l'opérateur assignation `<-`
    `Ctrl`+`Entrée` : exécute le code sélectionné 
    (ou la commande ou se trouve le curseur si rien n'a été sélectionné)
    Ctrl + A : tout sélectionner
    Ctrl + C/X/V : copier/couper/coller classique
    Ctrl + z : annule la dernière modification
    `Ctrl` + `F` : ouvre le formulaire de chercher/remplacer
    `Ctrl` + `Shift` + `F` : recherche une expression dans plusieurs fichiers
    `Ctrl` + `I` : indente automatiquement le code sélectionné
    (ou la commande ou se trouve le curseur si rien n'a été sélectionné)
    Ctrl + Shift + C : bascule en commentaire le code   sélectionné 
    (ou la ligne où se trouve le curseur si rien n'a été sélectionné)
    Tab ou Ctrl + Espace : ouvre les propositions d'autocomplétion   
    (pour les noms de fonctions ou d'objets, et pour les chemins à l'intérieur de guillemets)

    F1 : sur une fonction R, affiche l'aide de la fonction 
    (si le package est chargé).  On peut aussi utiliser ?nom_fonction (ou ??nom_fonction).  
    La documentation de la fonction apparaîtra dans le panneau en bas à droite de RStudio.
    F2 : sur une fonction, affiche le code de la fonction 
    (sur une fonction personnalisée uniquement 
    si le script contenant la définition de la fonction est ouvert)

    Ctrl + ↑ : dans la console, affiche l'historique des commandes exécutées (et permet de les relancer)
    Ctrl + L : vide la console
    
    `Ctrl` + `+=` : Zoom positif (Menu View, Zoom In)
    `Ctrl` + `0à` : Annulation du zoom (Menu View, Actual Size)
    `Zoom négatif` (Menu View, Zoom Out)
    
    Ctrl + Alt + Shift + W : ferme tous les fichiers sauf le fichier courant
    
    Ctrl + Alt + I : insère un chunk R (dans une syntaxe markdown uniquement)
    
    `Tab` : autocomplétion

https://orion.agriculture/confluence/display/CER/Ergonomie+et+raccourcis+dans+RStudio

https://www.book.utilitr.org/03_fiches_thematiques/fiche_rprojects#raccourcis-utiles-pour-l%C3%A9dition-de-code

### L'espace de travail - le 'workspace'

L'espace de travail (ou 'workspace') est l’environnement de la session R. Il comprend tous les objets créés durant une session de travail sous R. Par exemple, lorsqu'on importe des données, elles deviennent un objet de type data.frame et sont intégrées à l’environnement global. De même lorsqu'on crée un objet, il vient s’inclure dans l'environnement.

Ces différents objets sont alors visibles dans l’onglet 'Environnement' de la fenêtre en haut à droite.

Pour connaître le répertoire de travail actuel, on utilise la fonction 'getwd()'.

Sous RStudio, le répertoire de travail est également affiché dans le quadrant inférieur gauche, en gris, en dessous de l'onglet 'Console'.

Pour lister les objets de l'environnement courant, il faut utiliser la fonction ls().

R va accumuler en mémoire un certain nombre d’objets (listes, vecteurs, fonctions…)
Pour tous les effacer pour repartir d’une mémoire vierge (au lancement d’un script par exemple), on peut utiliser la commande 'rm(list=ls())', suivie de 'gc()'

La fonction 'rm' permet d’effacer l’objet de son choix.

La commande rm(list=ls()) est censée libérer la mémoire utilisée par tous les objets, mais ce qu’elle fait réellement est de détruire les pointeurs vers les morceaux de mémoire utilisés. 

Le but principal de gc() est de montrer un rapport sur l’utilisation de la mémoire. Comme effet secondaire, l’appel de gc() déclenche le processus de collecte des déchets, en effaçant la mémoire. Par conséquent, comme le note la documentation gc, il est bon d’appeler gc() après qu’un objet volumineux ait été supprimé, car cette action incite R à libérer la mémoire qu’il n’utilise plus.


```{r, eval = FALSE}
getwd()

ls()

# Effacer ce qui se trouve dans l'espace de travail
rm(list=ls())

gc()

```

### Ne pas sauvegarder le fichier ".RData"

Les fichiers .RData sont des enregistrements de l'environnement de la session, avec notamment la présence de tables. En principe ce n'est pas très pertinent de l'enregistrer.

Il est recommandé de configurer RStudio pour ne pas sauvegarder de `.RData` (tous les objets créés dans un projet)

Menu R-studio → Tools → Global Options → General, partie Workspace → `Save workspace to .RData on exit` : mettre `Never`

Il est également recommandé de désactiver la restauration automatique de ces fichiers. Pour cela il faut aller dans le menu Tools > Global Options, dans l'onglet General, partie Workspace décocher la case `Restore .RData into workspace at startup`.

### Parenthèses et autres

Dans RStudio, les caractères marchant par paires (parenthèses, guillemets, accolades, crochets) sont automatisés. En sélectionnant du code et en appuyant sur le caractère ouvrant correspondant, RStudio place automatiquement les caractères au début et à la fin du code sélectionné. En plaçant le curseur après un caractère de ce type (par exemple une parenthèse fermante), RStudio va surligner l'autre caractère correspondant (par exemple la parenthèse ouvrante correspondante), permettant de visualiser les paires.

### Encodage

Dans Tools > Global options > Code > Saving, choisir le `Default text encoding` UTF-8 pour les caractères spéciaux. Sans encoding UTF-8, les caractères spéciaux (accents...) risquent d'être formatés de manière peu compréhensible

### Chemins
***Les anti-slash windows (\\) doivent être remplacés par des slash(/). ***

### Choix de l'affichage du séparateur décimal
```{r, eval = FALSE}
# séparateur décimal ,
options(OutDec= ",")

# options(encoding = "UTF-8",OutDec=',')
```
à placer en début de programme

### Travailler dans des projets

Il est recommandé de travailler avec les projets Rstudio, plutôt que les scripts R.

- Cela permet la portabilité : le répertoire de travail par défaut d'un projet est le répertoire où est ce projet. 

**Pour créer un projet : **
- Cliquer sur *Project* en haut à droite puis *New Project*.
_ ou bien faire `File > New Project`. 

On peut créer un projet `RStudio` :

1. Dans un nouveau dossier (`New Directory`) :
    + Pour un projet tout nouveau.

2. Dans un dossier existant (`Existing Directory`) :
    + Pour organiser des codes existants sous forme de projet.
    
Cocher la case en bas `Open in new session`.

La création d'un projet `RStudio` se traduit par :

* un fichier `.Rproj` est créé dans le dossier principal. Ce fichier sert à deux choses :
    + Il centralise les options du projet ;
    + Il sert de raccourci pour ouvrir le projet.
* le projet est chargé dans `RStudio`.

Une fois que le projet est créé, le nom du projet apparaît dans la barre de projet (tout en haut à droite). 

On peut accéder aux derniers projets ouverts avec le raccourci en haut à droite.

### Travailler avec un projet RStudio

Lorsqu'on ouvre un projet `RStudio` (en double-cliquant sur le fichier `.Rproj` par exemple) :

* Une nouvelle session `R` est ouverte ;
* L'historique des commandes `.Rhistory` du projet est chargé (s'il existe) dans le cadre `History` ;
* Le répertoire de travail *working directory* est par défaut le dossier-maître du projet (le dossier dans lequel se situe le fichier `.Rproj`).

Le répertoire de travail se situant à la racine du dossier créé, cela signifie que lors de l’importation, le chemin d’accès aux données sera automatiquement fixé à partir de cet endroit. De même, pour l'export, les fichiers seront également enregistrés à partir de la racine du dossier. 

C'est pourquoi, il est conseillé pour chaque projet de créer une arborescence avec les répertoires 'entree', 'pgm', 'sortie'.

```{r, eval = FALSE}
library(fs)

#  menu File|New Project Exemple_projet

# pour créer un dossier
# dir.create("nouveau_dossier")
dir.create("entree")
dir.create("pgm")
dir.create("sortie")
```
On peut ensuite utiliser les chemins relatifs pour l'import et l'export.

```{r, eval = FALSE}
# Chargement du chemin
chemin  <- "./entree/" 

# sauvegarde données
# Chargement du chemin 
chemin_sortie <- "./sortie/"

```

### Script R - entête de section

On peut utiliser quatre symboles - (ou #)  de suite pour créer un entête de section.

Par exemple :
```{r, eval = FALSE}
# Chargement du fichier de données ---- 
```

Cela permet de passer rapidement d'une section à l'autre et de masquer des sections.

### Forcer la NON utilisation de la notation scientifique

Pour cela, on va utiliser la valeur 100 au niveau de l’argument “scipens” :

```{r, eval = FALSE}
  # options par défaut 
  # options( "digits"=7, "scipen"=0) 
  # 1.520e+10 5.498e+08 7.220e-05 
options( "scipen"=100) 
```

***

<br>

# Les packages

Les _packages_ sont des regroupements de fonctions permettant de faciliter l'écriture de scripts R.

## Installation des packages

### Installation standard

L'installation est à réaliser _une seule fois_ pour une version de R donnée.

Il est recommandé d'utiliser la fonction `install.packages` pour installer et mettre à jour les _packages_.

Lors de l'ouverture d'un script, `RStudio` tente de détecter automatiquement si les _packages_ utilisés dans celui-ci sont installés. Dans le cas contraire, il affiche un bandeau en haut du script proposant d'installer les _packages_ manquants :
`▲ _package_ --- required but is not installed. Install Don't show again`

À l'ouverture, si un package est manquant, on a la mention en haut du fichier de code indiquant qu'un package (ou plusieurs) n'est pas installé.
<center>![](images/package_manquant.png)</center>

Il est préférable de ne pas installer des _packages_ en cliquant sur le bouton <kbd> Install </kbd> du bandeau. En effet, garder la trace des installations dans un script avec l'utilisation de la fonction `install.packages` permet de faciliter les réinstallations de  _packages_, lors de changements de version de R notamment.

Les _packages_ `R` sont spécifiques à la version de `R` avec laquelle ils ont été installés. La principale conséquence pratique de cette caractéristique est qu'il faut réinstaller les _packages_ lors d'un changement de version de `R`. 

Cette réinstallation est facilitée en utilisant un script `installation_packages.R` avec une ligne `install.packages` pour chaque _package_ utilisé.

Il peut arriver qu'un programme génère une erreur parce qu'on utilise un _package_ dans une version trop ancienne. Pour mettre à jour un _package_, il suffit de le réinstaller avec `install.packages`.

Des problèmes d’installation ?

Ce n’est pas parce que vous avez des messages/ des warnings/ du rouge dans votre console que vous avez eu un problème d’installation.
Les problèmes d’installation sont relativement souvent liés à un problème dans l’installation des dépendances. 
Dans ce cas cela peut être une bonne idée d’installer la dépendance “qui coince” en premier, puis retenter l’installation du package.

### Installer une version plus récente que la version compilée (le fichier binaire)

L'argument `type` de `install.packages` permet de choisir une méthode alternative à la valeur par défaut, `"win.binary"`. Utiliser `type = "source"` permet par exemple de récupérer une version plus récente d'un _package_.
```{r, eval = FALSE}
install.packages("nom_du_package", type="source")
```

### Installer depuis un fichier

Il est aussi possible d'installer un _package_ depuis une archive compressée (fichiers ".zip" pour les binaires Windows ou ".tar.gz" pour les _packages_ _source_). Pour indiquer que la source est un fichier local, il est obligatoire de spécifier `repos = NULL`.

```{r, eval = FALSE}
install.packages("chemin/en/local/package1_x.y.z.zip", repos = NULL)
```

Si le fichier est de type "source" (extension .tar.gz), Rtools peut s'avérer nécessaire.

### Installation de Rtools en cas de difficulté sur son poste de travail

`R sur son poste local`

Installer une seule fois Rtools (outils de compilation pour R) à partir de https://cran.r-project.org/bin/windows/Rtools. 
Par exemple https://cran.r-project.org/bin/windows/Rtools/rtools40.html

Il convient de télécharger rtools40-x86_64.exe vers `D:\user\R\packages` puis de lancer rtools40-x86_64.exe. 
Comme répertoire d'installation, choisir `D:\user\R\rtools40`. Décocher l'ensemble des options par défaut, notamment les options qui écrivent dans le registre.

Après l'installation, mettre la location des outils _make_ (bash, make, etc) dans le PATH.
```{r, eval = FALSE}
write('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', file = "~/.Renviron", append = TRUE)
```
Redémarrer R et verifier que _make_ peut être trouvé, ce qui devrait montrer le chemin (path) de l'installation de Rtools.
```{r, eval = FALSE}
Sys.which("make")
```
donne "D:\\user\\R\\rtools40\\usr\\bin\\make.exe",  
avant on avait par exemple "C:\\R\\rtools40\\usr\\bin\\make.exe" 

### Avoir des informations sur les packages installés

```{r, eval = FALSE}
# pour connaitre les chemins vers lesquels pointe R pour chercher des packages installés
.libPaths()
# "/var/data/gluster/volume0/CERISE/00-Espace-Personnel/prenom.nom/R/x86_64-pc-linux-gnu-library/4.0"

# éléments du répertoire :
list.files("~/CERISE/00-Espace-Personnel/prenom.nom/R/x86_64-pc-linux-gnu-library/4.0")

View(installed.packages()) # affiche tous les packages installés 

row.names(x=installed.packages(priority=c("base","recommended")))
row.names(x=installed.packages(lib.loc=c("~/CERISE/00-Espace-Personnel/prenom.nom/R/x86_64-pc-linux-gnu-library/4.0")))
```


### Installation de packages sur Cerise avec difficulté

Les dernières versions de certains packages ne peuvent parfois pas s'installer sur CERISE à cause de librairies du système d'exploitation absentes ou anciennes. Parfois aussi (mais pas toujours), installer une version précédente du package permet de contourner ce problème.

Voir le guide Installation de packages
https://orion.agriculture/confluence/display/CER/Installation+de+packages

Il faut d'abord installer `remotes` :

```{r, eval = FALSE}
install.packages("remotes")

# Tidyverse
remotes::install_version("tidyverse", "1.3.0")

# arrow
remotes::install_version("arrow", version = "3.0.0")

# btb
remotes::install_version("btb", version = "0.1.30.3")

# COGugaison
# Téléchargement de https://github.com/antuki/COGugaison/archive/refs/heads/master.zip
 
# → COGugaison-master.zip, on dézippe on enlève "-master", on re-zippe puis on upload dans Cerise.

devtools::install_local("/mon/chemin/vers/le/COGugaison.zip", INSTALL_opts = c("--no-lock"))

# FactoMineR
remotes::install_version("nloptr", version = "1.2.0")
remotes::install_version("FactoMineR", version = "2.0")

# Hmisc
remotes::install_version("Hmisc", version = "4.6-0")

# sf
remotes::install_version("sf", version = "0.9-0")

#raster
remotes::install_version("raster", version = "3.0-12")

# gstat
remotes::install_version("gstat", version = "2.0-6")

```

Installation de versions plus anciennes, en précisant un numéro de version
```{r, eval = FALSE}
remotes::install_version("sf", ">= 0.7-0", dependencies=TRUE, type="source")
# Warning: unable to access index for repository https://forge.agriculture.rie.gouv.fr/artifactory/ssp-cran-prod-local/src/contrib:
#   cannot open URL 'https://forge.agriculture.rie.gouv.fr/artifactory/ssp-cran-prod-local/src/contrib/PACKAGES'
# Downloading package from url: https://forge.agriculture.rie.gouv.fr/artifactory/cran-r-prod-remote/src/contrib/sf_1.0-14.tar.gz

```

Exemple d'installation d'une ancienne version de package en plusieurs étapes
```{r, eval = FALSE}
# suppression d'un package
remove.packages(pkgs="cli", 
                lib=c("~/CERISE/00-Espace-Personnel/prenom.nom/R/x86_64-pc-linux-gnu-library/4.0"))

# suppression de l'ensemble des packages pour repartir de zéro
remove.packages(pkgs=row.names(x=installed.packages(lib.loc=c("~/CERISE/00-Espace-Personnel/prenom.nom/R/x86_64-pc-linux-gnu-library/4.0"))), 
                lib=c("~/CERISE/00-Espace-Personnel/prenom.nom/R/x86_64-pc-linux-gnu-library/4.0"))

row.names(x=installed.packages(lib.loc=c("~/CERISE/00-Espace-Personnel/prenom.nom/R/x86_64-pc-linux-gnu-library/4.0")))
# NULL

# install.packages("tidyverse") 
# ERROR: dependency ‘ragg’ is not available for package ‘tidyverse’
# * removing ‘/var/data/gluster/volume0/CERISE/00-Espace-Personnel/prenom.nom/R/x86_64-pc-linux-gnu-library/4.0/tidyverse’
# Warning in install.packages :
#   installation of package ‘tidyverse’ had non-zero exit status

# installation d'une version plus ancienne tidyverse_1.3.2.tar.gz	2022-07-18
# https://cran.r-project.org/src/contrib/Archive/tidyverse/
# installation packages préalables
install.packages(c("broom", "dbplyr", "dtplyr", "googledrive", "googlesheets4", "httr", 
                    "modelr", "reprex", "rvest"))
install.packages("~/CERISE/01-Espace-de-Partage/SRISE/Pays-De-La-Loire/Partage_R/Christophe/packages/tidyverse_1.3.2.tar.gz",
                 repos = NULL, type = "source")
# Error in loadNamespace(j <- i[[1L]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]) : 
# namespace ‘forcats’ 0.5.0 is being loaded, but >= 0.5.1 is required
# namespace ‘ggplot2’ 3.3.2 is being loaded, but >= 3.3.5 is required
# namespace ‘haven’ 2.3.1 is being loaded, but >= 2.4.3 is required
# namespace ‘hms’ 0.5.3 is already loaded, but >= 1.1.1 is required
# namespace ‘jsonlite’ 1.7.1 is being loaded, but >= 1.7.2 is required
# namespace ‘lubridate’ 1.7.9 is being loaded, but >= 1.8.0 is required
# namespace ‘magrittr’ 1.5 is already loaded, but >= 2.0.1 is required
# namespace ‘readr’ 1.3.1 is being loaded, but >= 2.1.1 is required
# namespace ‘xml2’ 1.3.2 is already loaded, but >= 1.3.3 is required
install.packages("forcats")
install.packages("ggplot2")
install.packages("haven")
install.packages("hms")
install.packages("jsonlite")
install.packages("lubridate")
install.packages("magrittr")
install.packages("readr")
install.packages("xml2")
install.packages("readr")
install.packages("~/CERISE/01-Espace-de-Partage/SRISE/Pays-De-La-Loire/Partage_R/Christophe/packages/tidyverse_1.3.2.tar.gz", 
                 repos = NULL, type = "source")
# * DONE (tidyverse)
```
## Utilisation des packages

En début du code, on commence par charger le _package_ `nom_du_package` avec la commande `library(nom_du_package)`.
Le **chargement** consiste à indiquer à `R` que l'on souhaite utiliser le _package_ dans la session courante. 
C'est une opération qu'il faut réaliser _à chaque fois_ que l'on ouvre une session `R`.

Toutefois, si on utilise la fonction du package sous la forme nom_du_package::nom_fonction, cela n'est pas nécessaire. L'utilisation de l'opérateur :: évite ainsi de charger un package peu utilisé.

```{r, eval = FALSE}
# Charger les bibliotheques necessaires
# Packages souvent utilisés
library(dplyr)
library(openxlsx)
library(janitor) # pour nettoyer et préparer des données ('make_clean_names')
library(tidyr) # pour pivot

# Packages pouvant être utilisés
library(forcats)  # fonction "fct_collapse"
library(data.table)
library(tables) ## fonction tabular
library(kableExtra)
library(ggplot2)
library(rmarkdown)

```

Pour appliquer une fonction à un objet, la syntaxe est :
```{r, eval = FALSE}
nom_de_la_fonction(objet, attribut1, attribut2, ...)
```
Pour stocker le résultat de cette fonction dans une variable :
```{r, eval = FALSE}
ma_variable <- nom_de_la_fonction(objet, attribut1, attribut2, ...)
```


***

<br>

# Import / export

## Importer

La première étape d'une chaîne de traitement est d'accéder aux données à traiter. 
Il convient d'indiquer dans le script de préparation des données comment le fichier est arrivé, soit en codant les instructions de téléchargement, soit en ajoutant des commentaires qui permettront plus tard de reconstituer le jeu de données utilisé. 


- **Il est conseillé d'importer uniquement les colonnes dont on a besoin.** 
Dans le cas où on ne sait pas quelles sont les colonnes dont on a besoin, il est conseillé de commencer par importer un petit nombre de lignes (par exemple 1 000 ou 10 000) afin d’étudier les données et de choisir ensuite les colonnes à importer. 

### Importer des fichiers RDS


```{r, eval=FALSE}
library(dplyr)
library(janitor) # pour 'make_clean_names' pour standardiser la syntaxe des noms de colonnes

# import fichiers
chemin_geographie <- "~/CERISE/01-Espace-de-Partage/SRISE/Pays-De-La-Loire/Partage_R/
Christophe/Geographie/sortie/"

fichier_geographie_dep <- "dep_reg_lib.RDS"
fichier_geographie_reg <- "reg_lib.RDS"

geographie_dep <- readRDS(file = paste0(chemin_geographie,fichier_geographie_dep) ) %>% 
  as_tibble(.name_repair = make_clean_names)
geographie_reg <- readRDS(file = paste0(chemin_geographie,fichier_geographie_reg) ) %>% 
  as_tibble(.name_repair = make_clean_names)

# Chargement des données
# recensement agricole 2020 PDL DONNEES INDIVIDUELLES
chemin_pdl_20 <- "S:/Fichiers source/RA 2020_déf/BASES_RA2020_data_def_15avril2022/RDS/"
annee_ra_2020            <- 2020

exploit_pdl_2020 <- readRDS(file = paste0(chemin_pdl_20,
                                        "RA2020_EXPLOITATIONS_R52_220415_modif_27juin2022.rds")) %>% 
  as_tibble(.name_repair = make_clean_names)
# ident_pdl_2020 <- readRDS(file = paste0(chemin_pdl_20,"RA2020_IDENTIFICATION_R52_220415.rds") ) %>% 
#   as_tibble(.name_repair = make_clean_names)  
# pv_pdl_2020 <- readRDS(file = paste0(chemin_pdl_20,"RA2020_PRODVEG_R52_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# cult_pdl_2020 <- readRDS(file = paste0(chemin_pdl_20,"RA2020_SURF_SAU_R52_220415.rds") ) %>% 
#   as_tibble(.name_repair = make_clean_names)
pa_pdl_2020 <- readRDS(file = paste0(chemin_pdl_20,"RA2020_PRODANIM_R52_220415.rds") ) %>% 
 as_tibble(.name_repair = make_clean_names)
# COEFPBS <- readRDS(file = paste0(chemin_pdl_20,"RA2020_COEFS_PBS17_R52_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# cc_pdl_2020  <- readRDS(file = paste0(chemin_pdl_20,"RA2020_COM_CIRCOU_R52_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# COMCIRCUIT <- readRDS(file = paste0(chemin_pdl_20,"RA2020_COM_CIRCUIT_R52_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# div_pdl_2020  <- readRDS(file = paste0(chemin_pdl_20,"RA2020_DIVERSIF_R52_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# HORTI_PEPI <- readRDS(file = paste0(chemin_pdl_20,"RA2020_HORTI_PEPI_R52_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# LEGUMES <- readRDS(file = paste0(chemin_pdl_20,"RA2020_LEGUMES_R52_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
mo_pdl_2020 <- readRDS(file = paste0(chemin_pdl_20,"RA2020_MO_CHEF_COEXPL_R52_220415.rds") ) %>% 
  as_tibble(.name_repair = make_clean_names)
# MOFAM <- readRDS(file = paste0(chemin_pdl_20,"RA2020_MO_FAM_R52_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# PPAM <- readRDS(file = paste0(chemin_pdl_20,"RA2020_PPAM_R52_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# fichier_ra_otex_com_pdl_2020 <- readRDS(file = paste0(chemin_pdl_20,"RA2020_PBS_OTEX_COMMUNALES_220415.rds") )

# RA2020 DONNEES INDIVIDUELLES France
chemin_fr_20 <- "D:/user/RA2020/RA2020_source/RDS/"
exploit_fr_2020 <- readRDS(file = paste0(chemin_fr_20,"RA2020_EXPLOITATIONS_220415.rds") ) %>% 
  as_tibble(.name_repair = make_clean_names) %>% 
  filter(siege_dep %in% c("44","49","53","72","79","") )
# ident_fr_2020 <- readRDS(file = paste0(chemin_fr_20,"RA2020_IDENTIFICATION_220415.rds") ) %>% 
#   as_tibble(.name_repair = make_clean_names)  
# pv_fr_2020 <- readRDS(file = paste0(chemin_fr_20,"RA2020_PRODVEG_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# cult_fr_2020 <- readRDS(file = paste0(chemin_fr_20,"RA2020_SURF_SAU_220415.rds") ) %>% 
#   as_tibble(.name_repair = make_clean_names)
pa_fr_2020 <- readRDS(file = paste0(chemin_fr_20,"RA2020_PRODANIM_220415.rds") ) %>% 
 as_tibble(.name_repair = make_clean_names) 
# COEFPBS <- readRDS(file = paste0(chemin_fr_20,"RA2020_COEFS_PBS17_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# cc_fr_2020  <- readRDS(file = paste0(chemin_fr_20,"RA2020_COM_CIRCOU_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# COMCIRCUIT <- readRDS(file = paste0(chemin_fr_20,"RA2020_COM_CIRCUIT_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# div_fr_2020  <- readRDS(file = paste0(chemin_fr_20,"RA2020_DIVERSIF_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# HORTI_PEPI <- readRDS(file = paste0(chemin_fr_20,"RA2020_HORTI_PEPI_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# LEGUMES <- readRDS(file = paste0(chemin_fr_20,"RA2020_LEGUMES_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# mo_fr_2020 <- readRDS(file = paste0(chemin_fr_20,"RA2020_MO_CHEF_COEXPL_220415.rds") ) %>% 
#   as_tibble(.name_repair = make_clean_names)
# MOFAM <- readRDS(file = paste0(chemin_fr_20,"RA2020_MO_FAM_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# PPAM <- readRDS(file = paste0(chemin_fr_20,"RA2020_PPAM_220415.rds") ) %>% 
# as_tibble(.name_repair = make_clean_names)
# fichier_ra_otex_com_fr_2020 <- readRDS(file = paste0(chemin_fr_20,"RA2020_PBS_OTEX_COMMUNALES_220415.rds") )

```

### Importer des fichiers xlsx

L'utilisateur souhaite importer dans `R` des données issues de tableurs (extension`xlsx`).

- **Il est recommandé d'utiliser la fonction `read.xlsx()` du _package_ `openxlsx` pour importer des fichiers `xlsx`.**

Voici les principaux arguments et options de `read.xlsx()` :

| Argument         | Valeur par défaut     | Fonction                                                                                   |
|------------------|-----------------------|--------------------------------------------------------------------------------------------|
| `xlsxFile`       | Aucune                | Chemin d'accès vers un objet classeur ou une url vers un fichier `xlsx` à importer           |
| `sheet`          | `1`                     | Onglet à importer. Soit le nom de l'onglet, soit un numéro de l'onglet |
| `startRow`       | `1`                     | Ligne à partir de laquelle les données sont importées. Les lignes vides en haut d'un fichier sont toujours ignorées, quelle que soit la valeur de `startRow`    |
| `colNames`       | `TRUE`                  | Si `TRUE`, la première ligne de données sera utilisée comme nom de colonnes   |
|


```{r, eval = FALSE}
library(dplyr)
library(openxlsx)
library(janitor) # pour 'make_clean_names'

# import fichiers
chemin_entree <- "S:/ETUDES/En cours/memento_Christophe/entree/SAA/"
fichier_entree <- "cd2022-5_SAA_2021_provisoire_resultats_LIB.xlsx"
eff_volailles <- read.xlsx(xlsxFile=paste0(chemin_entree,fichier_entree), 
                         sheet = "Eff. volailles",colNames = TRUE,startRow = 1) %>% 
  as_tibble(.name_repair = make_clean_names) %>% 
  filter(region %in% c("52  -  Pays de la Loire","98  -  Total France métropolitaine") )


chemin <- "S:/ETUDES/En cours/memento_Christophe/entree/AgenceBio/"
fichier_nat <- "Export Productions Bio - National.xlsx"
an <- "2021"
agri_bio_vegetal_fr <- read.xlsx(xlsxFile=paste0(chemin,fichier_nat), 
                                 sheet = "Productions végétales",colNames = TRUE,startRow = 1) %>% 
  as_tibble(.name_repair = make_clean_names) %>% 
  filter(annee %in% c(an) & territoire %in% c("National","Pays de la Loire") )


# fichier annuel présent sur Cerise 
# 03-Espace-de-Diffusion/070_Production_lait/7020_Enqu_Annuelle_Laitiere/
EAL_2021_resultats_definitifs_septembre_2022
chemin_entree_2021 <- "~/CERISE/03-Espace-de-Diffusion/070_Production_lait/
7020_Enqu_Annuelle_Laitiere/EAL_2021_resultats_definitifs_septembre_2022/"

fichier_entree_liv_reg_dep <- "LIVRAISON_REGNDEP_2020_2021.xlsx"

laits_reg_dep_2021 <- read.xlsx(xlsxFile=paste0(chemin_entree_2021,fichier_entree_liv_reg_dep), 
                                sheet = "Sheet 1",colNames = TRUE,startRow = 1) %>% 
  as_tibble(.name_repair = make_clean_names) %>% 
  mutate(reg_dep_prod=paste0(regnprod,sep = "_",depprod),
         dep_prod=substr(depprod,2,3))  
```

https://www.book.utilitr.org/03_fiches_thematiques/fiche_import_tableurs#importer-un-fichier-xlsx-avec-le-package-openxlsx

### Importer des fichiers xls

L'utilisateur souhaite importer dans `R` des données issues de tableurs (extension type `xls`).

- **Il est recommandé d'utiliser la fonction `read_xls()` du _package_ `readxl` pour importer des fichiers `xls`.** 

Voici les principaux arguments et options de `read_xls()` :

| Argument         | Valeur par défaut     | Fonction                                                                                   |
|------------------|-----------------------|--------------------------------------------------------------------------------------------|
| `path`           | Aucune                | Chemin d'accès au fichier xls à importer                                           |
| `sheet`          | `NULL`                  | Onglet à importer Soit le nom de l'onglet, soit la position de l'onglet. Par défaut, sélectionne le premier onglet du fichier |
| `col_names`      | `TRUE`                  | `TRUE` pour utiliser la première ligne comme noms de colonne, `FALSE` pour obtenir les noms par défaut ou un vecteur de caractères donnant un nom à chaque colonne      |
| `col_types`      | `NULL`                  | Préciser le type des colonnes. Si `col_types = NULL`, `readxl` essaie de deviner le type des colonnes. Voir `?readxl::read_xls` pour l'usage de cette option |
| `na`             | ""                    | Vecteur de chaînes de caractères à interpréter comme des valeurs manquantes   |
| `skip`           | `0`                     | Nombre de lignes à ignorer avant d'importer les données |
| `n_max`          | `Inf`                | Nombre maximum de lignes de données à lire  |
          |


```{r, eval = FALSE}
library(dplyr)
library(readxl)

# Chargement du chemin #
chemin <- "S:/ETUDES/En cours/memento_Christophe/entree/volailles_qualite/Qualite_volailles_2021/"
fichier <- "Abattages_signes_qualite_2021_modif.xls"

volailles_pdl_espece_siqo <- read_xls(path = paste0(chemin,fichier), 
                                      sheet = "res_nouvelle_region_modif", 
                                      skip = 9) %>% 
  as_tibble(.name_repair = make_clean_names) %>% 
  filter(espece %in% c("siqo","PAYS DE LA LOIRE") )
```

* **Définir le type des colonnes** : le paramètre `col_types` permet de définir explicitement le type des colonnes et d'ignorer les colonnes qu'on ne souhaite pas importer. Pour cela, on passe au paramètre `col_types` un vecteur précisant le type parmi les possibilités suivantes :  
    * `"skip"` : ignorer la colonne (qui ne sera pas importée) ;
    * `"guess"` : le type de la variable est devinée par rapport à ses *modalités* ;
    * `"list"` : crée une liste ;
    * `"logical` pour une variable booléenne, `"numeric"` pour une variable numérique, `"date"` pour une date et `"text"` pour une variable caractère.
  
    Le type de la variable sera appliqué aux colonnes dans l'ordre défini par le vecteur. Exemple : `c("text","text","numeric","guess","skip","logical")`. Dans le cas où on souhaite définir le même type pour toutes les colonnes, il suffit de préciser une seule fois le type attendu (exemple `col_types = "text"`).

* **Gestion des `NA` ** : il est possible de préciser les valeurs qu'on souhaite considérer comme des `NA` avec le paramètre `na`. Par défaut, la valeur `""` est considérée comme `NA`.

https://www.book.utilitr.org/03_fiches_thematiques/fiche_import_tableurs#importer-un-fichier-xls-avec-le-package-readxl


### Importer des fichiers ods

L'utilisateur souhaite importer dans `R` des données issues de tableurs (extension `ods`).

- **Il est recommandé d'utiliser la fonction `read_ods` du _package_ `readODS` pour importer des fichiers `ods`.**

Voici les principaux arguments et options de `read_ods()` :

| Argument            | Valeur par défaut     | Fonction                                                                                   |
|---------------------|-----------------------|--------------------------------------------------------------------------------------------|
| `path`              | Aucune                | Le chemin du fichier `ods` à importer                                                        |
| `sheet`             | 1                     | Onglet à importer. Soit le nom de l'onglet, soit le numéro de l'onglet (utiliser de préférence le nom de l'onglet) |
| `col_names`         | `TRUE`                  | Indique si la première ligne de l'onglet contient les noms des variables               |
| `col_types`         | `NULL`                  | `NULL` pour laisser `R` deviner le type des variables à partir de l'onglet ou se reporter à `readr::type_convert` pour spécifier le type des variables | 
| `na`                | `""`                    | Vecteur donnant les chaîne de caractères interprétées comme des valeurs manquantes. Par défaut, `read_ods` convertit les cellules vides en données manquantes |
| `skip`              | `0`                     | Le nombre de lignes du fichier de données à ignorer avant de commencer à importer les données  |

```{r,  eval = FALSE}
library(readODS)

# Chargement du 3ème onglet
mesDonnees <- readODS::read_ods(path = chemin_ods, sheet = "Sheet3", skip = 5)

# Chargement du chemin 
chemin_entree <- "S:/ETUDES/En cours/Fiche filière volailles/conjoncture volailles/2022_s1/entree/"
fichier_entree <- "COMEXOEUFS_France.ods"
oeufs <- read_ods(path=paste0(chemin_entree,fichier_entree), sheet = "Données",skip = 0)

# Chargement du chemin 
chemin  <- "~/CERISE/01-Espace-de-Partage/SRISE/Pays-De-La-Loire/Partage_R/Christophe/Volailles/entree/" 
fichier_cotation <- "Cotations_modif.ods"
# Import + ajout annee mois
vol_oeufs_cot <- read_ods(path=paste0(chemin,fichier_cotation), 
                   sheet = "VolaillesOeufsLapinsMensuel",skip = 2) %>% 
  as_tibble(.name_repair = make_clean_names) 

```

### Importer des fichiers csv

L'utilisateur souhaite importer dans `R` des données stockées sous forme de fichiers plats (formats `.txt`, `.csv`, `.tsv`).

Le *package* `readr` propose plusieurs fonctions adaptées pour importer des fichiers plats de taille limitée (moins de 1 Go) :

* `read_csv()` : lecture d'un csv délimité par des virgules, avec un point comme marqueur décimal
* `read_csv2()` : lecture d'un csv séparé par des points-virgules, avec une virgule comme marqueur décimal
* `read_delim()` : fonction plus générale et paramétrable, pour lire des fichiers délimités.

Il faut charger le *package* `readr` pour utiliser ces fonctions :

```{r, message = FALSE, warning = FALSE} 
library(readr)
```

```{r, eval = FALSE}
library(dplyr)
library(readr)
library(janitor)

# source : https://agreste.agriculture.gouv.fr/agreste-web/disaron/COMPT0005_NRP/detail/
# Comptes régionaux de l'agriculture : productions et subventions sur les produits
# Fichier de données secrétisées FDS_COMPT0005_NRP.zip

# import fichiers

# Chargement du chemin 
chemin <- "S:/ETUDES/En cours/memento_Christophe/entree/volailles_abattage/ABATVOL_2021/"
chemin_entree <- "./entree/comptes_prod/"

fichier_entree <- "DIFFABATVOL_2021.csv"
fichier_entree_prod <- "FDS_COMPT0005_NRP_2020.txt"


volailles_pdl <- read_csv2(file = paste0(chemin,fichier_entree)) %>%  
  as_tibble(.name_repair = make_clean_names) %>% 
  filter(reg %in% c("52") ) %>%
  mutate(siret=as.character(siret))

# lecture d’un txt séparé par des points-virgules, avec un point comme marqueur décimal
comptes_prod <- read_delim(file = paste0(chemin_entree,fichier_entree_prod),
                           delim = ";",
                           locale = locale(decimal_mark = ".")) %>%  
  as_tibble(.name_repair = make_clean_names) %>% 
  rename(libelle_produits=libelle_produits_compt0005_nrp_dim1,
         libelle_indic_n027=libelle_indicateurs_n027) 

```

La fonction `read_delim()` de `readr` permet d'importer les données d'un fichier csv.

`read_csv()`, `read_csv2()` et `read_tsv()` sont des implémentations pré-renseignées de `read_delim` pour lire des fichiers plats avec séparateurs (caractère délimiteur de colonne) **,** **;** et **tabulaire**.


**Il est plus simple de sélectionner des colonnes avec `fread()` qu'avec les fonctions du *package* `readr`**. Il est donc recommandé d'utiliser `fread()` lorsqu'on souhaite sélectionner facilement les colonnes à importer.


https://www.book.utilitr.org/03_fiches_thematiques/fiche_import_fichiers_plats#utiliser-la-fonction-read_delim


### Importer des fichiers SPSS (.sav)

L'utilisateur souhaite importer dans `R` des données stockées sous forme de fichiers SPSS.

La méthode recommandée est d'utiliser la fonction `read_spss()` du *package* `haven`.

```{r, eval = FALSE}
# Charger le package haven
library(haven)
# Importer un fichier SPSS
tableau <- haven::read_spss(paste0(chemin,fichier_entree))

# Importer un fichier SPSS
fichier_entree_mensuel <- "COLLECTE_TOUS_LAITS.sav"
laits_mensuel_1 <- haven::read_spss(paste0(chemin_entree_mensuel,fichier_entree_mensuel)) %>% 
  as_tibble(.name_repair = make_clean_names) 
```
### Importer des fichiers SAS

L'utilisateur souhaite importer dans `R` des données stockées sous forme de tables SAS.

La méthode recommandée est d'utiliser la fonction `read_sas()` du *package* `haven`.

```{r, eval = FALSE}
# Charger le package haven
library(haven)
# Importer une table SAS.
# Utilisation de la table de passage des codes communes depuis 1943
# vers les codes communes en vigueur en 2022,
comdepuis1943_com2022 <- read_sas("S:/ETUDES/En cours/memento_Christophe/entree/geographie/geo2022/fcodcomm.sas7bdat")

```
## Exporter

### Exporter des fichiers RDS

```{r , eval = FALSE}
# Chargement du chemin 
chemin_sortie <- "S:/ETUDES/En cours/Fiche filière volailles/conjoncture volailles/2022_s1/sortie/"
fichier_sortie_rds <- "oeufs_cot_det_2022_2021_an_mois.RDS"
saveRDS(object = oeufs_cot_det_2022_2021_an_mois, file = paste0(chemin_sortie,fichier_sortie_rds) )
```

### Exporter des fichiers xlsx

```{r , eval = FALSE}
library(openxlsx)

# export 
# Chargement du chemin 
chemin_sortie <- "S:/ETUDES/En cours/memento_Christophe/sortie/"
fichier_sortie <- "abattoirs_volaille_pdl_2021.xlsx"
write.xlsx(volailles_sum,file= paste0(chemin_sortie,fichier_sortie) )

# export dans plusieurs feuilles
chemin_sortie <- "S:/ETUDES/En cours/memento_Christophe/sortie/"
fichier_sortie <- "agri_bio_2021.xlsx"
# définir les noms de feuilles pour chaque tableau (data frame)
dataset_names <- list('tab1' = agri_bio_vegetal_tab1_final, 
                      'tab2' = agri_bio_vegetal_tab2_final,
                      'tab3' = agri_bio_animal_tab3_final)

# exporter chaque tableau vers des feuilles séparées dans le même fichier Excel
write.xlsx(dataset_names, file= paste0(chemin_sortie,fichier_sortie) )

```
https://www.statology.org/r-export-to-excel-multiple-sheets/

***

<br>

# Manipulation de variables (colonnes)

## Exploration des variables 

```{r , eval = FALSE}
library(dplyr) # pour glimpse
library(labelled) # pour look_for
library(questionr) # pour describe

# noms des variables
names(exploit_2020)

# liste des variables séparées par une virgule
paste0(names(exploit_2020),collapse = ",")

# nom, type et extrait des variables
str(exploit_2020)
str(exploit_2020,list.len=Inf)

glimpse(exploit_2020)
look_for(exploit_2020)
describe(exploit_2020)

# modalités d'une variable caractère ou numérique
unique(exploit_2020$siege_dep)
# modalités triées d'une variable caractère ou numérique
sort(unique(exploit_2020$siege_dep))
# modalités d'une variable séparées par une virgule
paste0(unique(exploit_2020$siege_dep),collapse = ",")

# modalités d'un facteur
levels(exploit_2020$siege_reg)

# 6 premières lignes
head(volailles_pdl)
# Les 4 premières lignes du data.frame
head(volailles_pdl, 4)

# 6 dernières lignes
tail(volailles_pdl)

```

`Afficher les valeurs et manipuler les variables`

- Pour afficher la table, plusieurs façons : "clic" dans l'environnement Rstudio, `View(base)`, `print(base)`, `base`.

- Pour accéder à une variable : fonction `pull()`

Par exemple :
```{r,  eval = FALSE}
str(pull(base, DEP))
```


## Création de variables 

On assigne un contenu à une variable au moyen de `<-`
La flèche d'assignation peut être écrite avec le raccourci clavier alt + "-" (tiret du 6 ou signe 'moins' du pavé numérique).

ATTENTION : un nom de variable ne peut pas commencer par un chiffre.
```{r inter_1}
ma_variable <- 2
ma_variable <- "Toulouse"
ma_variable <- c("Toulouse", "Nantes", "Strasbourg")
ma_variable <- 1:10
```
`paste0()` pour concaténer des variables
'separate()' pour séparer des variables

On souhaite créer de nouvelles variables

<center>![](images/mutate.png)</center>

* `mutate()` : ajouter et modifier des variables

La fonction `mutate()` permet de créer/modifier une variable (ou plusieurs).

```{r, eval = FALSE}
table_sortie <- mutate(table_entree,
                        nouvelle_variable = definition_variable)

# Par exemple pour créer une variable :
base <- mutate(base, 
               log_SUPERF = log(SUPERF),
               code_prelevement_caract = as.character(code_prelevement))

```

La fonction `mutate()` permet également de modifier une variable. Dans ce cas la syntaxe est la même que ci-dessus, mais les noms d'entrée et de sortie sont les mêmes :

```{r,  eval = FALSE}
# Par exemple pour modifier une variable existante :
base <- mutate(base, 
               log_SUPERF = 100 * log_SUPERF,
               code_prelevement = as.character(code_prelevement))

df <- mutate(df, 
             densite = P14_POP / SUPERF,
             tx_natal = 1000 * NAISD15 / P14_POP,
             tx_mort = 1000 * DECESD15 / P14_POP)

# ajout d'une variable avec mutate
agri_bio_vegetal_fr_tab1 <- agri_bio_vegetal_fr %>%   
  filter(groupe_de_productions %in% c("Toutes productions") ) %>% 
  select(annee,territoire,nombre_de_producteurs,
         surface_bio_et_en_conversion_en_ha,surface_en_conversion_en_ha,surface_bio_en_ha,
         part_bio_de_la_sau_en_percent) %>%  
  mutate(part_bio_sau_plus_percent = paste0(part_bio_de_la_sau_en_percent," %") )

# ajout d'une variable avec une modalité déterminée
volailles_fr <- read.xlsx(xlsxFile=paste0(chemin,fichier), 
                           sheet = "res-France",colNames = TRUE,startRow = 1) %>% 
  as_tibble(.name_repair = make_clean_names) %>% 
  mutate(reg="France") %>% 
  select(reg,espece,total_poids)

# ajout d'une variable par calcul
# passage d'ares en hectares
sau_pbs_2010_2020 <- exploit_2010 %>% 
  mutate(sau_tot = sau / 100, annee=annee_ra_2010) 
# calcul solde
oeufs <- oeufs %>%   
            mutate(solde = Exportation_Nombre - Importation_Nombre)

# on peut préciser l'emplacement de la nouvelle colonne avec .before ou .after
groupe_produits_laitiers_2021_France <- produits_laitiers_2021_2 %>% 
  group_by(code_produit,libellé_produit) %>% 
  summarise(production_2020=arrondi(sum(finiqte1, na.rm = TRUE) ,digits=0),
            production_2021=arrondi(sum(finiqte, na.rm = TRUE) ,digits=0),
            établissements_2020=sum(nbfiniqte1, na.rm = TRUE),
            établissements_2021=sum(nbfiniqte, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(territoire="France",.before=1)

# lors d'un mutate avec un group_by, 
# il est conseillé d'ajouter le suffixe correspondant au nom de variable
# par exemple _reg
# VOLAILLEFIL	Élevez-vous des volailles ?
exploit_dont_volailles_2020 <- exploit_dont_volailles_2020 %>% 
  mutate(nb_exploit_volailles_France = sum(volaillefil, na.rm = TRUE),
         part_exploit_volailles_France = nb_exploit_volailles_France / n()*100) %>% 
  group_by(reg) %>% 
  mutate(nb_exploit_volailles_reg = sum(volaillefil, na.rm = TRUE),
         part_exploit_volailles_reg = nb_exploit_volailles_reg / n()*100) %>% 
  ungroup() 

nb_exploit_dont_volailles_2020 <- exploit_dont_volailles_2020 %>% 
  distinct(reg,nb_exploit_volailles_France,part_exploit_volailles_France,
           nb_exploit_volailles_reg,part_exploit_volailles_reg)

nb_exploit_dont_volailles_2020_pdl <- exploit_dont_volailles_2020 %>% 
  filter(reg == "52") %>% 
  group_by(dep) %>% 
  mutate(nb_exploit_volailles_dep = sum(volaillefil, na.rm = TRUE),
         part_exploit_volailles_dep = nb_exploit_volailles_dep / n()*100)

# ajout niveau dep, reg et fm
recolte_bois_dep_reg <- recolte_bois_depart %>%  
  group_by(categorie) %>% 
  mutate(valeur_fm = sum(valeur)) %>%
  ungroup() %>% 
  group_by(reg,categorie) %>% 
  mutate(valeur_reg = sum(valeur)) %>%
  ungroup() %>%  
  rename(valeur_dep = valeur) %>% 
  select(dep,reg,categorie,
           valeur_fm,
           valeur_reg,
           valeur_dep,
           libdep,libreg)

# nombre des exploitants par groupe
repart_diplome_max_groupe1 <-  mo_2020_diplome_max %>% 
  mutate(n_tot = n()) %>%
  group_by(dipl_max_groupe1) %>% 
  summarise(nb=n(), percent = n() / n_tot * 100) %>% 
  distinct() %>% 
  adorn_totals(where = c("row"), name="Ensemble")

# utilisation de la fonction last, qui permet de récupérer la valeur de la dernière ligne
# à manier avec précaution (ne pas modifier l'ordre au préalable par exemple)
exploit_otex_dep_reg_fm <- exploit_otex_pdl %>% 
  left_join(exploit_otex_dep,
            by= "otex_regroup") %>% 
  adorn_totals(where = "row",
               name = "Ensemble") %>% 
  mutate(a01_part_otex_fm = a01_n_exploit_fm / last(a01_n_exploit_fm) *100,
         b02_part_otex_reg = b02_n_exploit_reg / last(b02_n_exploit_reg) *100,
         c03_part_otex_85 = dep_85 / last(dep_85) *100,
         d04_part_otex_72 = dep_72 / last(dep_72) *100,
         e05_part_otex_53 = dep_53 / last(dep_53) *100,
         f06_part_otex_49 = dep_49 / last(dep_49) *100,
         g07_part_otex_44 = dep_44 / last(dep_44) *100) %>% 
  mutate(across(contains("part"), ~ arrondi(.,digits=3)))

# sau irriguées
exploit_anim_produit_grand_pdl <- exploit_anim_produit_grand_pdl %>% 
  group_by(seuil_produit) %>% 
  mutate(indic_10_sau_reg = sum(sau_tot),
         sau2_reg = sum(rowSums(across(contains("cultsur")))),
         sau3_reg = sum(across(contains("cultsur"))),
         indic_11_sau_irrig_reg = sum(across(contains("irrisur"))),
         .after=nom_dossier) %>% 
  ungroup()
```

**La fonction `mutate()` permet de créer de nouvelles colonnes ou de modifier des colonnes existantes.** Il est possible d'utiliser toutes sortes de fonctions à l'intérieur d'une étape `mutate()`. Le code suivant crée une variable `NB_EQUIP_3PLUS` qui vaut `TRUE` si le nombre d'équipement est supérieur ou égal à 3, et `FALSE` sinon. 

```{r, eval=FALSE}
bpe_ens_2018_tbl %>% 
  mutate(NB_EQUIP_3PLUS = (NB_EQUIP >= 3))
```

Pour créer une nouvelle variable, on utilise un nom de variable qui n'existe pas encore dans la table. Pour modifier une variable qui existe déjà, on utilise directement le nom de cette variable.

Voici quelques utilisations fréquentes de `mutate()` :
 
| Action                                      | Code                                                                    |
|---------------------------------------------|-------------------------------------------------------------------------|
| Calculer une somme cumulée                  | `mutate(NB_EQUIP_CUM = cumsum(NB_EQUIP, na.rm = TRUE))`  |
| Calculer un total                           | `mutate(NB_EQUIP_TOT = sum(NB_EQUIP, na.rm = TRUE))`                    |
| Sommer deux variables                       | `mutate(NB_EQUIP_DOUBLE = NB_EQUIP + NB_EQUIP)`                    |
| Extraire une sous-chaine de caractères      | `mutate(CATEGORIE_EQ = str_sub(TYPEQU, 1L, 1L))`                    |
 

### `separate` : scinder une colonne en plusieurs

Il arrive que plusieurs informations réunies en une seule colonne et qu'on souhaite les séparer. La fonction `separate` permet d'effectuer cette opération. Elle prend trois arguments principaux :

- le nom de la colonne à scinder ;
- un vecteur indiquant les noms des nouvelles variables à créer ;
- le séparateur `sep` indique à quel endroit la variable doit être scindée. Par défaut `separate` scinde au niveau des caractères non-alphanumérique (espace, symbole, etc.). Si l'on indique un nombre entier `n`, alors la colonne est scindée après le n-ième caractère.

Voici un exemple qui utilise la table des communes du Code Officiel Géographique. Dans cette table, la colonne `com` (code commune Insee) contient deux informations : le numéro du département et le numéro de la commune.

```{r, eval=FALSE}
cog_com_2019_tbl <- doremifasolData::cog_com_2019 %>% as_tibble()
cog_com_2019_tbl
```

Voici comment on peut utiliser `separate` pour scinder `com` en deux nouvelles colonnes `code_dep` et `code_com`. La colonne `com` disparait, car par défaut `separate` supprime la colonne scindée. Si on souhaite la conserver, il faut ajouter l'option `remove = FALSE`.

```{r, eval=FALSE}
cog_com_2019_tbl %>% 
  separate(com, c("code_dep", "code_com"), sep = 2)

# séparation d'une variable date ("22-09-2022") en "jour","mois","annee"
oeufs_cot_det <- oeufs_cot_det %>% 
  separate(DATE,sep="-", into = c("jour","mois","annee"))

# on divise les noms de colonnes en "indicateur" et "territoire"
# on transpose le niveau dep en colonnes
agreg_anim_produit_grand_dep_reg <- agreg_anim_produit_grand_dep_pdl_long %>%
  separate(indicateur_territoire, into = c("indicateur", "territoire"), sep = "_dep_") %>%
  arrange(territoire) %>% 
  pivot_wider(names_from = territoire, 
              values_from = donnees_territoire) %>%
  arrange(indicateur) 
```

### `unite` : regrouper plusieurs colonnes en une seule

La fonction `unite` permet est de réaliser l'opération inverse de `separate` : regrouper plusieurs colonnes en une seule. Elle prend trois arguments principaux :

- le nom de la colonne à créer ;
- un vecteur indiquant les noms des variables à regrouper ;
- le séparateur `sep` qui indique quel séparateur doit être introduit entre les variables regroupées (par défaut, `unite` utilise le caractère `_`).

Voici un exemple où l'on regroupe le code commune Insee et le nom officiel de la commune, avec " - " comme séparateur. Les colonnes `com` et `ncc` disparaissent, car par défaut `unite` supprime les colonnes regroupées. Si on souhaite les conserver, il faut ajouter l'option `remove = FALSE`.

```{r, eval=FALSE}
cog_com_2019_tbl %>% 
  unite(code_et_nom, c("com", "ncc"), sep = " - ") 
```

### Ajout d'une colonne "numéro de ligne" 

row.names

```{r , eval = FALSE}
# ajout colonne numéro de ligne
# creation d'une variable identifiant reprenant le numéro de ligne 
produits_laitiers <- read.xlsx(xlsxFile=paste0(chemin_entree,fichier_entree), 
                         sheet = "produits laitiers",colNames = TRUE,startRow = 12) %>% 
  as_tibble(.name_repair = make_clean_names) 

produits_laitiers <- produits_laitiers %>% 
  mutate(ident=row.names(produits_laitiers), .before=1)

# filtre en fonction du numéro de ligne
# avec l'identifiant “numéro de ligne”
# Ajout d’une colonne “numéro de ligne”
# creation d'une variable identifiant reprenant le numéro de ligne 
vab_agri_2020_2 <- vab_agri_2020 %>% 
  mutate(ident=row.names(vab_agri_2020), .before=1) %>% 
  filter(ident %in% 1:15) %>% 
  mutate(total=as.numeric(total)) %>% 
  left_join(geographie_reg,
            by= "libreg")
```

## Sélectionner des variables

<center>![](images/select.png)</center>

* `select()` : sélectionner des variables par leur nom

La fonction `select()` permet de sélectionner les variables voulues.

- sélection par liste blanche
```{r, eval=FALSE}
table_sortie <- select(table_entree, Variable1, Variable2, ..., VariableN)
```

- sélection par liste noire (supprimer)
```{r, eval=FALSE}
table_sortie <- select(table_entree, -Variable1, -Variable2, ..., -VariableN)
```

Par exemple :
```{r,  eval = FALSE}
base_select <- select(base, CODGEO, LIBGEO, P14_POP)
base_select <- select(base, -CODGEO)
```

select
```{r , eval = FALSE}
agri_bio_vegetal_tab1_final <- agri_bio_vegetal_tab1_final %>% 
  select(c("annee","vegetal","Loire-Atlantique","Maine-et-Loire", "Mayenne","Sarthe","Vendée",
           "Pays de la Loire","National"))

agri_bio_vegetal_fr_tab1 <- agri_bio_vegetal_fr %>%   
  filter(groupe_de_productions %in% c("Toutes productions") ) %>% 
  select(annee,territoire,nombre_de_producteurs,
         surface_bio_et_en_conversion_en_ha,surface_en_conversion_en_ha,surface_bio_en_ha,
         part_bio_de_la_sau_en_percent) %>%  
  mutate(part_bio_sau_plus_percent = paste0(part_bio_de_la_sau_en_percent," %") )
```
Une sélection négative est aussi possible avec 'select(-variable_a_enlever)'.
```{r , eval = FALSE}
# conversion en caractère
agri_bio_vegetal_fr_tab1_car <- agri_bio_vegetal_fr_tab1 %>% 
  mutate(across(c(nombre_de_producteurs,surface_bio_et_en_conversion_en_ha,
                  surface_en_conversion_en_ha,surface_bio_en_ha,
                  part_bio_de_la_sau_en_percent), as.character ) ) %>% 
  select(-c(part_bio_de_la_sau_en_percent) )
```

On peut aussi directement renommer une variable dans l'opération `select()`

```{r , eval = FALSE}
prelevementb <- select(prelevement, date_p = date_prelevement, code_prelevement,
                       code_reseau, code_station)
```

`select()` possède ce qu'on appelle des [helpers](https://dplyr.tidyverse.org/reference/select.html) qui permettent de gagner du temps dans l'écriture d'une sélection. 

Exemple : sélectionner toutes les variables qui commencent par "code_" : 

```{r , eval = FALSE}
prelevementb <- select(prelevement, starts_with("code_"))
```

Exemple : enlever de la sélection les variables dont les noms contiennent "type_reg"  :

```{r , eval = FALSE}
# A partir du tableau transposé, ajout du total régional
bio_pdl_animaux_large_2 <- bio_pdl_animaux_large %>% 
  adorn_totals(where = "row", name = "Pays de la Loire" ) %>% 
  select(-c(contains("type_reg")))
```

Exemple : sélectionner les variables dont les noms sont contenus dans un vecteur de chaînes de caractères :

```{r , eval = FALSE}
mes_variables <- c("code_prelevement", "code_intervenant", "code_reseau", "date_prelevement")
prelevementb <- select(prelevement, one_of(mes_variables))
```

**La fonction `select()` permet de sélectionner des variables par leur nom, ou par une condition sur leur nom.** 

- Avec une liste de noms de variables. Le code suivant sélectionne le code commune, le type d'équipement et le nombre d'équipement dans la base permanente des équipements :
 
```{r , eval = FALSE}
  bpe_ens_2018_tbl %>% 
    select(DEPCOM, TYPEQU, NB_EQUIP)
```

- Avec une condition logique. Par exemple, la fonction `starts_with("DEP")` permet de sélectionner toutes les variables dont le nom commence par "DEP". 

```{r , eval = FALSE}
  bpe_ens_2018_tbl %>% 
    select(starts_with("DEP"))

bio_pdl_dep_ab <- bio_pdl_dep_large2 %>%
  select(dep,c(contains("ab_")))

```
    Le tableau suivant donne la liste des conditions utilisables avec `select()` :

| Fonction                    | Signification |
|-----------------------------|----------------------------------------------------------------------|
| `select(starts_with("...")` | dont le nom commence par "..."  |
| `select(ends_with("...")`   | dont le nom se termine par "..."  |
| `select(contains("...")`    | contient "..."  |
| `select(matches("...")`     | vérifie une expression régulière   |
| `select(all_of(...))`       | sélectionne les colonnes listées dans un vecteur en paramètre |
| `select(any_of(...))`       | identique à `all_of()`, mais sans erreur si la colonne n'existe pas |
| `select(everything())`      | toutes les colonnes (utile pour mettre une nouvelle colonne devant les autres)      |

On peut aussi indiquer une plage de colonnes (soit par les noms de variables, soit par les numeros de colonne, par exemple ci-après on pourrait indiquer 1:4 au lieu de haircolor:weight)

```{r , eval = FALSE}
data <- data  %>% 
  select(catdata, haircolor:weight)
```


- On peut aussi renommer des colonnes avec la syntaxe `select(data, nouveau_nom = selection_colonne)` :

```{r , eval = FALSE}
  bpe_ens_2018_tbl %>% 
    select(dept = DEP, depcom = DEPCOM)
```


## Renommer des colonnes (variables)

* `rename()` : renommer des variables ;

La fonction `rename()` permet de renommer une variable (ou plusieurs).

```{r, eval = FALSE}
base <- rename(base, nouveau_nom = ancien_nom)

# Exemple
base_rename <- rename(base, ZONE_EMPLOI = ZE)

# renommage 2 lignes intitulés
volailles_pdl_siqo2 <- volailles_pdl_siqo %>%   
  rename(espece_poulets_coquelets_siqo_label_rouge=label_rouge_2,
         espece_poulets_coquelets_siqo_aoc_aop=aoc_aop_3,       
         espece_poulets_coquelets_siqo_agri_bio=agri_bio_4,       
         espece_poulets_coquelets_siqo_aut_signe_off=aut_signe_off_5 
         )
```


La fonction `rename()` permet de renommer des variables. La syntaxe est la suivante :  `rename(data, nouveau_nom = ancien nom)`. Voici un exemple :

```{r , eval = FALSE}
bpe_ens_2018_tbl %>% 
  rename(code_commune = DEPCOM)
```

La fonction `rename_with()` permet de renommer un groupe de colonnes avec une fonction. La syntaxe est la suivante :  `rename_with(data, nom_fonction, selection_colonnes)`. Voici un exemple qui met en minuscules tous les noms de colonnes :

```{r , eval = FALSE}
bpe_ens_2018_tbl %>% 
  rename_with(tolower)

# on renomme _reg en _dep_ensemble
# on renomme toutes les colonnes contenant "_reg" à la fin par "_dep_ensemble"
# ensuite en enlevant le suffixe _dep, il restera 44,49,53,72,85,ensemble
agreg_anim_produit_grand_dep_pdl_b <- agreg_anim_produit_grand_dep_pdl_a %>%
  rename_with(.cols = contains("reg"),
              ~str_replace(.,"_reg", "_dep_ensemble"))
```
## Extraire des éléments d’une chaîne de caractères

La fonction `substr()` permet d’extraire une sous-chaine à partir d’une chaine de caractères. 

`substr(x,start,stop)` extrait une sous-chaîne de caractères.

Le premier argument est la chaine de caractères, 
le deuxième correspond au début de sous-chaine 
et le troisième à la fin de la sous-chaine que nous voulons extraire.

```{r , eval = FALSE}
depcom <- "44001"
 
dep <- substr(depcom,1,2) 
# La sous-chaine débute au 1er caractère et se finit au 2e
# Ainsi on extrait "44"

# Filtrer les enregistrements de la région Pays de la Loire
bio_pdl <- bio %>% 
  filter(substr(codecommuneinsee,1,2) %in% c('44','49','53','72','85'))

# Créer une variable dep pour département
bio_pdl <- bio %>% 
  filter(substr(codecommuneinsee,1,2) %in% c('44','49','53','72','85')) %>% 
  mutate(dep=substr(codecommuneinsee,1,2))

# Extraire une chaîne de caractères avec `substr`  
laits_mensuel_2 <- laits_mensuel_1 %>% 
  mutate(dep_etab=substr(sircodpost,1,2),
         dep_prod=substr(dep,2,3) )
```

## Conversion d'une variable caractère en numérique

On utilise la fonction 'as.numeric'.

```{r , eval = FALSE}
agri_bio_vegetal_fr <- agri_bio_vegetal_fr %>% 
  mutate(across(c(surface_bio_et_en_conversion_en_ha,surface_en_conversion_en_ha,surface_bio_en_ha,
                  part_bio_de_la_sau_en_percent), as.numeric ) ) 
```
En cas de lignes vides, cela crée des valeurs NA (not available) et produit un messsage d'avertissement dans la console. C'est un message non bloquant.
   ***Warning messages:***
   1: Problem with `mutate()` input `..1`.
   NAs introduits lors de la conversion automatique
   Input `..1` is `across(...)`.
   
On utilise la fonction `as.numeric`, combinée à `across` pour l'appliquer à un ensemble de variables.  
   
```{r , eval = FALSE}
# import fichiers
chemin_entree <- "S:/ETUDES/En cours/memento_Christophe/entree/BAEA/"
fichier_entree <- "baea_diff_2020_reg_52_Pays_de_la_Loire.xlsx"

otex <- read.xlsx(xlsxFile=paste0(chemin_entree,fichier_entree), 
                         sheet = "ETP - OTEX",colNames = TRUE,startRow = 7) %>% 
  mutate(across(-c("Orientation.technico-économique.(OTEX)"), as.numeric) ) %>% 
  rename(otex_lib="Orientation.technico-économique.(OTEX)") %>% 
  mutate(otex_code = substr(otex_lib,1,4) )

# Pourcentage en colonne
produits_a17_percent <- produits_a17_large %>% 
   mutate(an_2021_imports_percent_col = an_2021_imports / sum(an_2021_imports) * 100,
          an_2022_imports_percent_col = an_2022_imports / sum(an_2022_imports) * 100,
          an_2021_exports_percent_col = an_2021_exports / sum(an_2021_exports) * 100,
          an_2022_exports_percent_col = an_2022_exports / sum(an_2022_exports) * 100,
          an_2021_I_sem1_percent_col = an_2021_I_sem1 / sum(an_2021_I_sem1) * 100,
          an_2021_I_sem2_percent_col = an_2021_I_sem2 / sum(an_2021_I_sem2) * 100,
          an_2022_I_sem1_percent_col = an_2022_I_sem1 / sum(an_2022_I_sem1) * 100,
          an_2022_I_sem2_percent_col = an_2022_I_sem2 / sum(an_2022_I_sem2) * 100,
          an_2021_E_sem1_percent_col = an_2021_E_sem1 / sum(an_2021_E_sem1) * 100,
          an_2021_E_sem2_percent_col = an_2021_E_sem2 / sum(an_2021_E_sem2) * 100,
          an_2022_E_sem1_percent_col = an_2022_E_sem1 / sum(an_2022_E_sem1) * 100,
          an_2022_E_sem2_percent_col = an_2022_E_sem2 / sum(an_2022_E_sem2) * 100,
          .after=a17_lib_detail) %>% 
   mutate(across(where(is.numeric), ~ arrondi(.,digits=3)))

# type.convert pour transformer en numérique poids_produit_en_tec (caractère) qui a comme séparateur ","
viande_volaille_tec_2021 <- read.xlsx(xlsxFile=paste0(chemin,"cd2022-5_SAA_2021_provisoire_resultats_LIB.xlsx"), 
                         sheet = "Volailles finies produites",colNames = TRUE,startRow = 1) %>% 
  as_tibble(.name_repair = make_clean_names) %>% 
  filter(region %in% c("52  -  Pays de la Loire","98  -  Total France métropolitaine")  ) %>% 
  mutate(an_2021=type.convert(poids_produit_en_tec,dec=","),
         reg = case_when(
           region %in% c("52  -  Pays de la Loire") ~ "pdl",
           region %in% c("98  -  Total France métropolitaine") ~ "fm") ) %>% 
  select(c(reg,libelle_culture,an_2021)) 

```

## Conversion d'une variable numérique en caractère

On utilise la fonction 'as.character'.

```{r , eval = FALSE}
# conversion en caractère
agri_bio_vegetal_fr_tab1_car <- agri_bio_vegetal_fr_tab1 %>% 
  mutate(across(c(nombre_de_producteurs,surface_bio_et_en_conversion_en_ha,
                  surface_en_conversion_en_ha,surface_bio_en_ha,
                  part_bio_de_la_sau_en_percent), as.character ) ) %>% 
  select(-c(part_bio_de_la_sau_en_percent) )
```


## Recodification de variables

### avec `recode()`
```{r , eval = FALSE}
# ajout date en nombre
lait_chevre3 <- lait_chevre2  %>%
  mutate(code_mois = recode(mois,
                            Janvier = "01",
                            Février = "02",
                            Mars = "03",
                            Avril = "04",
                            Mai = "05",
                            Juin = "06",
                            Juillet = "07",
                            Août = "08",
                            Septembre = "09",
                            Octobre = "10",
                            Novembre = "11",
                            Décembre = "12"))

# ajout date en lettres
laits_mensuel_chevre_2 <- laits_mensuel_chevre_1  %>%
  mutate(mois = recode(code_mois,
                            "01"="Janvier",
                            "02"="Février",
                            "03"="Mars",
                            "04"="Avril",
                            "05"="Mai",
                            "06"="Juin",
                            "07"="Juillet",
                            "08"="Août",
                            "09"="Septembre",
                            "10"="Octobre",
                            "11"="Novembre",
                            "12"="Décembre"))
                            
# otex en clair
# recode(x, old = new)
exploit_vaches_otex_clair <- exploit_vaches_otex %>% 
  mutate(otex_libelle = recode(otefda_coef17,
                               "1516"="Grandes cultures",
                               "2829"="Maraîchage, horticulture",
                               "3500"="Viticulture",
                               "3900"="Fruits ou autres cultures permanentes",
                               "4500"="Bovins lait",
                               "4600"="Bovins viande",
                               "4700"="Bovins mixte",
                               "4800"="Ovins, caprins, autres herbivores",
                               "5074"="Porcs, volailles",
                               "6184"="Polyculture, polyélevage",
                               "9000"="Exploitations non classées",
                                .default = "autre"))
                                
# Calculer par département et statut 
# le nombre d’exploitations ayant des vaches,
# l’effectif de vaches et la pbs
exploit_vaches_statut <- exploit_bovins_c %>% 
  filter(cheptq_111000>0) %>% 
  mutate(statut_libelle = recode(statut,
                                 "01"="1 - Exploitant individuel",
                                 "02"="2 - GAEC",
                                 "03"="3 - EARL",
                                 .default = "4 - Autres statuts"))

nb_exploit_vaches_statut <- exploit_vaches_statut %>% 
  group_by(siege_dep,statut_libelle) %>% 
  summarise(nb_expl=n(),
            vaches=sum(cheptq_111000),
            pbs=sum(pbstot_coef17)) %>% 
  ungroup() %>% 
  arrange(siege_dep)

# ajout de la comparaison au niveau reg et au niveau FM (en %)
recolte_bois_dep_reg <- recolte_bois_dep_reg %>%
  mutate(valeur_dep_percent_reg = valeur_dep/valeur_reg*100,
         valeur_dep_percent_fm = valeur_dep/valeur_fm*100,
         valeur_reg_percent_fm = valeur_reg/valeur_fm*100,
         .after=dep) %>% 
  mutate(across(contains("percent"), ~ arrondi(.,digits=3)))

```
### avec `ifelse()`

Avec `ifelse` :
- `variable = ifelse(condition(x), valeur_si_oui, valeur_si_non)` permet d'affecter *valeur_si* ou  *valeur_si_non* à *variable* en fonction du fait que *x* répond à *condition*.
Exemple : création d'une variable résultat pour savoir si les résultats de nos analyses sont bons, ou non.

```{r , eval = FALSE}
analyseb <- mutate(analyse, resultat_ok = ifelse(code_remarque %in% c(1, 2, 7, 10),
                                                 yes = TRUE, no = FALSE))
```

qui peut se résumer, lorsque `yes = TRUE` et `no = FALSE`, à :
```{r , eval = FALSE}
analyseb <- mutate(analyse, resultat_ok = code_remarque %in% c(1, 2, 7, 10))
```

On peut créer une nouvelle variable, commençant par un caractère commun à plusieurs modalités, avec 'startsWith'

```{r , eval = FALSE}
# Filtrer les enregistrements concernant les pommes
bio_pdl_pommes_yc_terre <- bio_pdl %>% 
  mutate(libelle_ab_2 = ifelse(startsWith(libelleonab, "Pomme"), "Pommes", "hors_pommes")) %>% 
  filter(libelle_ab_2 %in% c("Pommes"))

unique(bio_pdl_pommes$bio_pdl_pommes_yc_terre)
# "Pommes de table" "Pommes de terre (hors féculière)" "Pommes à cidre et à jus" "Pommes (sans précision)"  

bio_pdl_pommes <- bio_pdl %>% 
  mutate(libelle_ab_2 = ifelse(startsWith(libelleonab, "Pomme"), "Pommes", libelleonab)) %>% 
  filter(libelle_ab_2 %in% c("Pommes") & libelleonab != "Pommes de terre (hors féculière)")
```

### avec `case_when()`

Avec `case_when()` :
- `case_when()` permet d'étendre la logique de `ifelse()` à des cas plus complexes.
Les conditions mises dans un `case_when()` ne sont pas exclusives. De ce fait, il faut pouvoir déterminer l'ordre d'évaluation des conditions qui y sont posées. Cet ordre s'effectue de bas en haut, c'est à dire que la dernière condition évaluée (celle qui primera sur toutes les autres) sera la première à écrire.
Exemple: On va ici calculer des seuils fictifs sur les analyses.

```{r , eval = FALSE}
analyseb <- mutate(analyse, classe_resultat_analyse = case_when(
  resultat_analyse == 0     ~ "1",
  resultat_analyse <= 0.001 ~ "2",
  resultat_analyse <= 0.01  ~ "3",
  resultat_analyse <= 0.1   ~ "4",
  resultat_analyse > 0.1    ~ "5",
  TRUE                      ~ ""
  ))
```

```{r , eval = FALSE}
# nomenclature cultures
agri_bio_vegetal_fr_cultures <- agri_bio_vegetal_fr %>%   
    mutate(cultures_2 = case_when(
    groupe_de_productions %in% c("Toutes productions") ~ "1_Surface totale",
    sous_groupe_de_productions %in% c("Céréales") ~ "2_Céréales",
    sous_groupe_de_productions %in% c("Oléagineux","Protéagineux") ~ "3_Oléo-protéagineux",
    sous_groupe_de_productions %in% c("Légumes secs","Légumes frais",
                    "Plantes à parfum, aromatiques et médicinales") ~ "4_Légumes, fruits et PPAM",
    groupe_de_productions %in% c("Fruits (yc à coque)") 
                      & sous_groupe_de_productions %in% c("Toutes") ~ "4_Légumes, fruits et PPAM",
    sous_groupe_de_productions %in% c("Viticulture") ~ "5_Vigne",
    sous_groupe_de_productions %in% c("Cultures fourragères",
                                      "Surfaces toujours en herbe") ~ "6_Fourrage et STH",
    groupe_de_productions %in% c("Autres surfaces") 
                      & sous_groupe_de_productions %in% c("Toutes") ~ "7_Autres",
    TRUE ~ "autre cas - doublon")
  )

# nomenclature animaux
agri_bio_animal_fr_animaux <- agri_bio_animal_fr %>%   
  mutate(animaux_2 = case_when(
    groupe_de_productions %in% c("Vaches laitières") ~ "1_Vaches laitières",
    groupe_de_productions %in% c("Vaches allaitantes") ~ "2_Vaches viande",
    groupe_de_productions %in% c("Brebis viande") ~ "3_Brebis viande",
    groupe_de_productions %in% c("Brebis laitières") ~ "4_Brebis laitières",
    groupe_de_productions %in% c("Chèvres") ~ "5_Chèvres",
    groupe_de_productions %in% c("Truies") ~ "6_Truies reproductrices",
    groupe_de_productions %in% c("Poulets de chair") ~ "7_Poulets de chair",
    groupe_de_productions %in% c("Poules pondeuses") ~ "8_Poules pondeuses",
    TRUE ~ "autre cas - doublon")
  )
  
# Modification de la nomenclature agrégée libelle_ab_regroupt pour les animaux avec les regroupements :
# On conserve le détail pour les autres animaux
bio_pdl_nomenclature_animaux <- bio_pdl_nomenclature %>% 
  mutate(libelle_ab_regroupt = case_when(
    libelle_ab_regroupt %in% c("Vaches allaitantes","Vaches laitières") ~ "Vaches",
    libelle_ab_regroupt %in% c("Brebis viande","Brebis laitières") ~ "Brebis",
    libelle_ab_regroupt %in% c("Porcs charcutiers","Truies") ~ "Porcs",
    libelle_ab_regroupt %in% c("Poulets","Poules pondeuses","Canards",
                            "Pintades","Dindes","Autres volailles") ~ "Volailles",
    libelle_ab_regroupt %in% c("Lapins","Lapines reproductrices") ~ "Lapins",
    TRUE ~ libelle_ab_regroupt)
  ) 
sort(unique(bio_pdl_nomenclature_animaux$libelle_ab_regroupt))
  
# nb chefs et coexploitants
stats_chefcoexpl_statutdirig <- mo_2020 %>% 
  mutate(statut_dirig=case_when(statutdirig=="1" ~ "Chef d'exploitation",
                               statutdirig=="2" ~ "Coexploitant",
                               TRUE ~ statutdirig)) %>% 
  group_by (statut_dirig) %>% 
  summarise(nb=n()) %>% 
  adorn_totals(where=c("row"))

# Formation des chefs et coexploitants des exploitations
# si niveau égal, on indique dipl_max agricole
mo_2020_diplome_max <-  mo_2020_install2010 %>% 
  mutate(filiere_dipl_max = case_when(as.numeric(mofgene) > as.numeric(mofagri) ~ "general",
                                   TRUE ~ "agricole"),
          dipl_max=case_when(filiere_dipl_max=="general" ~ mofgene,
                             filiere_dipl_max=="agricole" ~ mofagri),
         dipl_agri=if_else(mofagri %in% c("23","24","25","26","27","28"),1,0),
         dipl_max_groupe1=case_when(dipl_max %in% c("00","10") ~ "a_Aucune scolarisation ou niveau primaire",
                                   dipl_max  %in% c("11","23","24") ~ "b_ niveau brevet CAP BEP",
                                   dipl_max %in% c("25","26") ~ "c_Niveau bac",
                                   dipl_max %in% c("27","28") ~ "d_Niveau études supérieures",
                                   TRUE ~ dipl_max),
         mofgene_car=case_when(mofgene=="00" ~ "Aucune scolarisation",
                              mofgene=="10" ~ "Niveau CEP ou scolarisé(e) jusqu'au primaire",
                              mofgene=="11" ~ "Niveau BEPC, brevet ou scolarisé(e) jusqu'au collège",
                              mofgene=="23" ~ "Niveau CAP (certificat d'aptitude professionnelle)",
                              mofgene=="24" ~ "Niveau BEP (brevet d'études professionnelles)",
                              mofgene=="25" ~ "Niveau baccalauréat général, brevet supérieur, bac techno",
                              mofgene=="26" ~ "Niveau baccalauréat pro., brevet pro. de technicien",
                              mofgene=="27" ~ "Niveau diplôme de 1er cycle universitaire, BTS, DUT",
                              mofgene=="28" ~ "Niveau d'études supérieures longues, diplôme d'ingénieur, ...",
                              TRUE ~ mofgene),
         mofagri_car=case_when(mofagri=="00" ~ "Aucune scolarisation",
                               mofagri=="11" ~ "Niveau BEPC, brevet ou scolarisé(e) jusqu'au collège",
                               mofagri=="23" ~ "Niveau CAP (certificat d'aptitude professionnelle)",
                               mofagri=="24" ~ "Niveau BEP (brevet d'études professionnelles)",
                               mofagri=="25" ~ "Niveau baccalauréat technologique agricole, bac pro agricole",
                               mofagri=="26" ~ "Niveau baccalauréat de technicien agricole (BTA), BEA,BPREA",
                               mofagri=="27" ~ "Niveau diplôme de 1er cycle universitaire, BTS, DUT",
                               mofagri=="28" ~ "Niveau d'études supérieures longues, diplôme d'ingénieur, ...",
                               TRUE ~ mofagri)
  )

```

### comparaisons entre `recode()`, `ifelse()` et `case_when()`

ifelse
```{r , eval = FALSE}
laits_mensuel_chevre_cerise <- laits_mensuel_2 %>%
  filter(type %in% c("CNB","CB")) %>% 
  mutate(reg_etab = ifelse(dep_etab %in% c("44","49","53","72","85"),
                           yes = "PDL", no = "hors PDL"),
         reg_prod = ifelse(dep_prod %in% c("44","49","53","72","85"),
                           yes = "PDL", no = "hors PDL"))

# en fonction du numéro de ligne
produits_laitiers_3 <- produits_laitiers_2 %>% 
  mutate(code_produit = case_when( 
    code_produit %in% c("062999 et 072999") ~ "062999_072999",
    code_produit %in% c("144221, 223, 224") ~ "144221_144223_144224",
    code_produit %in% c("188100 et 188220") ~ "188100_188220",
    code_produit %in% c("249319 et 249325") ~ "249319_249325",
    TRUE ~ code_produit),
    territoire = ifelse(ident %in% 2:22,"France",territoire),
    territoire = ifelse(ident %in% 23:45,"Pays de la Loire",territoire))
```

case_when(), comparativement à recode() et ifelse()
```{r , eval = FALSE}
# Créer un type_regroupement à partir de la variable 'type'
unique(exploit_lait2_production$type)
# 1- Créer un type_regroupement, avec la méthode 'case_when'
exploit_lait2_production <- exploit_lait2_production %>%
  mutate(type_regroupement = case_when(     
    type %in% c("VB","VNB") ~ "Vaches",
    type %in% c("CB","CNB") ~ "Chevres",
    type %in% c("BB","BNB") ~ "Brebis",
    TRUE ~ "autre"))
# 2- Créer un type_regroupement_1, avec la méthode 'recode'
exploit_lait2_production <- exploit_lait2_production %>%
  mutate(type_regroupement_1 = recode(type,
                               "VB"="Vaches",
                               "VNB"="Vaches",
                               "CB"="Chevres",
                               "CNB"="Chevres",
                               "BB"="Brebis",
                               "BNB"="Brebis",
                               .default = "autre"))
# 3- Créer un type_regroupement_2, avec la méthode 'ifelse'
exploit_lait2_production <- exploit_lait2_production %>%
  mutate(type_regroupement_2 = ifelse(type %in% c("VB","VNB"),yes = "Vaches",no = type),
         type_regroupement_2 = ifelse(type %in% c("CB","CNB"),yes = "Chevres",no = type_regroupement_2),
         type_regroupement_2 = ifelse(type %in% c("BB","BNB"),yes = "Brebis",no = type_regroupement_2))
         
```

### avec `fct_collapse()`
fct_collapse pour les facteurs, autrement dit des valeurs catégorielles
Cette fonction transforme les niveaux d’un facteur, soit pour les renommer soit pour les regrouper.

```{r , eval = FALSE}
library(forcats)  # fonction "fct_collapse"

# regroupements par type de volailles
volailles_pdl$espece_regrpt1 <- fct_collapse(volailles_pdl$libelle_espece,
                                                "b11-poulets" =  c("Poulets (yc coquelets)",
                                                                   "Chapons,poulardes",
                                                # "Coqs et poules de réforme",
                                                "Poules de réforme (filière œufs de consommation)",
                                                "Coqs et poules de réforme (reproducteurs)"),
                                                "c12-dindes" = c("Dindes"),
                                                # "3-pintades" = c("Pintades (yc chaponnées)"),
                                                "d14-canards" = c("Canards à rôtir","Canards gras"),
                                                # "5-oies" =  c("Oies à rôtir","Oies grasses"),
                                                # "6-petites_volailles" =  c("Pigeons","Cailles"),
                                                "e17-lapins" = c("Lapins")  ) 

```


## Recodification de variables numériques

La fonction `cut()` permet de découper une variable quantitative (de type numérique) en un certain nombre de classes (plages de valeurs).

Elle génère un objet de type factor (variable qualitative, variable catégorielle ordonnée). 

On précise les intervalles (les amplitudes ou les limites des classes) avec l’argument `breaks` (points de rupture).

Les symboles dans les noms attribués aux classes ont leur importance : 
( signifie que la frontière de la classe est exclue, 
tandis que [ signifie qu’elle est incluse.
Ainsi, (20,40] signifie « strictement supérieur à 20 et inférieur ou égal à 40 ».
         
`right = FALSE` pour fermé à gauche (c’est-à-dire incluant), ouvert à droite (c’est-à-dire n’incluant pas) [inf,sup)

<center>![](images/intervalles.png)</center>

On peut indiquer manuellement les noms des modalités avec `labels` (étiquettes).

Exemple : cut(variable_quanti, seq(from = 0, to = 120, by = 5)) => de 0 à 120 par paliers de 5

Il convient parfois de préciser l’argument `include.lowest = TRUE` pour ne pas oublier d’inclure l’observation avec la valeur minimale (ou maximale, pour right = FALSE ), puisque par défaut les intervalles ont des bornes ouvertes (c’est-à-dire n’incluant pas) à gauche. 

```{r , eval = FALSE}
exploit_anim_produit_grand_pdl <- exploit_anim_produit_grand_pdl %>% 
  mutate(tr_sau = cut(sau_tot, 
                      breaks = c(0, 10, 20, 50, 100, 200, 250, Inf), 
                      right = FALSE,
                      labels = c("01_moins de 10 ha",
                                 "02_de 10 à moins de 20 ha",
                                 "03_de 20 à moins de 50 ha",
                                 "04_de 50 à moins de 100 ha",
                                 "05_de 100 à moins de 200 ha",
                                 "06_de 200 à moins de 250 ha",
                                 "07_250 ha ou plus")),
         .after=nom_dossier) 

exploitants_2010 <- fam_2010 %>% 
  filter(famlien %in% c("10", "11", "12", "13"))  %>% 
  mutate(nom_dossier = id_dossier,
         annee = annee_ra_2010,
         age = annee_ra_2010 - as.integer(famanais), 
         tr_age_10 = cut(age, 
                         breaks = c(0, seq(from = 40, to = 60, by = 10), Inf), 
                         right = FALSE,
                         labels = c("moins de 40 ans",
                                    "de 40 à 49 ans",
                                    "de 50 à 59 ans",
                                    "60 ans ou plus"))
# Levels: [0,40) [40,50) [50,60) [60,Inf]
# Levels: moins de 40 ans, de 40 à 49 ans, de 50 à 59 ans, 60 ans ou plus
```


## Somme des variables 

On cherche à agréger des données.

>* `summarise()` : calculer une statistique résumé à partir de données *
>* `group_by()` : faire des opérations par groupe *

### Globalement

<center>![](images/summarise.png)</center>

La fonction `summarise()` permet d'agréger des données, en appliquant une fonction sur les variables pour construire une statistique sur les observations de la table. C'est une fonction dite de “résumé”.

```{r , eval=FALSE}
summarise(table_entree, NomVariableAgregee = Fonction(NomVariableEtude))

base_med <- base_extrait %>%
  summarise(population_med = median(P14_POP, na.rm = TRUE))
```

La fonction `summarise()` retourne un data.frame.

### Selon un facteur

<center>![](images/groupby.png)</center>

La fonction `summarise()` couplée à `group_by()` permet de calculer des statistiques pour chaque modalité d'une variable qualitative. Avec `group_by()`, on précise les variables qui formeront des groupes, sur lesquels on appliquera une fonction :

```{r, eval=FALSE}
TableauGroupes <- group_by(table_entree, Variable1, ..., VariableN)
summarise(TableauGroupes, NomVariableAgregee = Fonction (NomVariableEtude))
```

Par exemple, si on souhaite avoir la médiane de la variable P14_POP, pour chaque ZE et chaque région :
```{r , eval=FALSE}
base_reg_ann <- base_extrait %>% 
  group_by(ZE, REG) %>%
  summarise(population_med = median (P14_POP, na.rm = TRUE))
```


Exemples avec n, sum

On peut avoir des NA car les valeurs manquantes sont absorbantes. Pour éviter cela, il convient d'ajouter `na.rm = TRUE`

`distinct` filtre les lignes du tableau pour ne conserver que les lignes distinctes, en supprimant toutes les lignes en double.

```{r , eval = FALSE}

# nb exploitations par dep
nb_exploit_2020 <- exploit_2020 %>% 
              mutate(annee=annee_ra_2020) %>% 
              select(nom_dossier,
                     dep_2020=siege_dep,
                     annee) %>% 
  group_by(annee = factor(annee, levels = c(annee_ra_2020)),dep_2020,
           .drop = FALSE) %>% 
  summarise(`nombre total d'exploitations` = n() )

# nb exploitations par dep
nb_exploit_2020_reg <- exploit_2020 %>% 
  select(nom_dossier,siege_dep) %>% 
  mutate(territoire = "Pays de la Loire",
         nb_total_exploitations = n() ) %>% 
  distinct(territoire,nb_total_exploitations)

# nb exploitations par dep
nb_exploit_2010_2020 <- exploit_2010 %>% 
  mutate(annee=annee_ra_2010) %>% 
  select(annee,
         dep_2020=siege_dep_2020,
         nom_dossier = id_dossier,
  ) %>% 
  bind_rows(exploit_2020 %>% 
              mutate(annee=annee_ra_2020) %>% 
              select(nom_dossier,
                     dep_2020=siege_dep,
                     annee)) %>% 
  group_by(annee = factor(annee, levels = c(annee_ra_2010, annee_ra_2020)),dep_2020,
           .drop = FALSE) %>% 
  summarise(`nombre total d'exploitations` = n() )

# somme des regroupements par type de volailles
volailles_pdl1 <- volailles_pdl %>%   
            group_by(reg,espece_regrpt1) %>%     
            mutate(tec_regrpt = sum(total_poids / 1000) ) %>% 
            ungroup()

# somme des regroupements par abattoir par type de volailles
volailles_abattoir <- volailles_pdl %>%   
  group_by(siret,espece_regrpt1) %>%     
  filter(espece_regrpt1 %in% c("b11-poulets","c12-dindes","d14-canards","e17-lapins"))  %>% 
  mutate(tec_regrpt = sum(poids / 1000, na.rm = TRUE ) ) %>% 
  filter(!is.na(tec_regrpt) & tec_regrpt != 0)  %>% 
  select(reg,dep,siret,rsoc,espece_regrpt1,tec_regrpt) %>% 
  distinct()

volailles_abattoir_44 <- volailles_pdl %>%   
  group_by(siret,espece_regrpt1) %>%     
  filter(espece_regrpt1 %in% c("b11-poulets","c12-dindes","d14-canards","e17-lapins")  & dep=='44')  %>% 
  mutate(tec_regrpt = sum(poids / 1000, na.rm = TRUE ) ) %>% 
  filter(!is.na(tec_regrpt) & tec_regrpt != 0)  %>% 
  select(reg,dep,siret,rsoc,espece_regrpt1,tec_regrpt) %>% 
  distinct()

# calcul somme pdl fm + evolution
viande_volaille_sum <- viande_volaille_tec_lib %>% 
  group_by(reg) %>%
  summarise(an_2021 = sum(an_2021), an_2020 = sum(an_2020)) %>%
  mutate(espece = "07_Total") %>% 
  ungroup()

viande_volaille_evol <- viande_volaille_tec_lib %>% 
  bind_rows(viande_volaille_sum) %>% 
  mutate(evol_2021_2020 = paste0(arrondi((((an_2021/an_2020)-1)*100),0)," %"),
         an_2021 = (arrondi(an_2021/1000,0) )
  ) %>% 
  arrange(desc(reg),espece) 

# moyenne
# age moyen
age_moyen <- exploitants_2010 %>% 
            mutate(annee = annee_ra_2010,
                  age = annee_ra_2010 - as.integer(famanais) ) %>%
  bind_rows(mo_2020 %>% 
            mutate(annee = annee_ra_2020,
                  anais = replace(anais, which(anais == 0 | anais == 9999), NA), 
                  # il existe des valeurs nulles d'années de naissance (2 dans la Manche !)
                  age = annee_ra_2020 - anais) ) %>% 
  group_by(annee = factor(annee, levels = c(annee_ra_2010, annee_ra_2020)),
           nom = "âge moyen des chefs d'exploitation et coexploitants",
           .drop = FALSE) %>% 
  summarise(age_moy = mean(age, na.rm = TRUE) )
  
# calcul moyenne semestrielle
oeufs_cot_det_2022_2021_an_mois <- oeufs_cot_det_2022_2021_an_mois %>%   
  mutate(moy_sem_1_2021 = rowMeans((across(an_2021_01:an_2021_06)),na.rm = TRUE),
         moy_sem_1_2022 = rowMeans((across(an_2022_01:an_2022_06)),na.rm = TRUE),
         moy_sem_2_2021 = rowMeans((across(an_2021_07:an_2021_12)),na.rm = TRUE),
         moy_sem_2_2022 = rowMeans((across(an_2022_07:an_2022_12)),na.rm = TRUE),
         moy_an_2021 = rowMeans((across(an_2021_01:an_2021_12)),na.rm = TRUE),
         moy_an_2022 = rowMeans((across(an_2022_01:an_2022_12)),na.rm = TRUE))
         
# calcul moyenne semestrielle
# avec rowwise() (fonction dplyr) et c_across() 
# pour travailler dans les lignes, en combinaison avec rowwise()
vol_2022_mois <- vol_2022_mois %>%  
  mutate(moy_an = mois_total /12) %>% 
  rowwise() %>%
  mutate(moy_sem_1 = mean(c_across(mois_01:mois_06), na.rm = TRUE),
         moy_sem_2 = mean(c_across(mois_07:mois_12), na.rm = TRUE),
         moy_an_b = mean(c_across(mois_01:mois_12), na.rm = TRUE))
# rowwise() est juste une forme spéciale de regroupement,
# donc pour l'annuler, ajouter à la fin ungroup()
# avec rowMeans (fonction base R) et across()
vol_2021_mois <- vol_2021_mois %>%   
            mutate(moy_sem_1 = rowMeans(across(mois_01:mois_06), na.rm = TRUE),
                   moy_sem_2 = rowMeans(across(mois_07:mois_12), na.rm = TRUE),
                   moy_an = mois_total /12,
                   moy_an_b = rowMeans(across(mois_01:mois_12), na.rm = TRUE))

```
**La fonction `summarise()` permet de calculer une ou plusieurs statistiques à partir de la table de données.** Cette fonction est souvent utilisée après la fonction `group_by()` pour calculer des statistiques par groupe, et elle conduit à une agrégation de la table en fonction des groupes définis par la fonction `group_by` (par défaut une agrégation sur l'ensemble de la table). Le code suivant calcule le nombre total d'équipements dans la BPE `sum(NB_EQUIP, na.rm = TRUE)`, et le nombre total de boulangeries `sum(NB_EQUIP * (TYPEQU == "B203"), na.rm = TRUE)`.

```{r , eval = FALSE}
bpe_ens_2018_tbl %>% 
  summarise(
    NB_EQUIP_TOT = sum(NB_EQUIP, na.rm = TRUE),
    NB_BOULANGERIES_TOT = sum(NB_EQUIP * (TYPEQU == "B203"), na.rm = TRUE)
  )
```

Il est possible d'utiliser un grand nombre de fonctions différentes avec `summarise()`. Ces fonctions peuvent être combinées entre elles, et il est possible d'en définir de nouvelles. Voici quelques fonctions courantes :
 
| Fonction                          | Code           |
|-----------------------------------|----------------|
| Moyenne                           | `mean()`       |
| Médiane                           | `median()`     |
| Ecart-type                        | `sd()`         |
| Minimum                           | `min()`        |
| Maximum                           | `max()`        |
| Valeur de la première valeur      | `first()`      |
| Valeur de la dernière valeur      | `last()`       |
| Nombre de lignes                  | `n()`          |
| Nombre de valeurs distinctes      | `n_distinct()` |
| Somme                             | `sum()`        |
| Somme cumulée                     | `cumsum()`     |

### Fonctions `mutate()` et `summarise()` 

Les fonctions `mutate()` et `summarise()` calculent toutes les deux de nouvelles variables. Il arrive donc fréquemment qu'on les confonde, ou qu'on ne sache pas laquelle il faut utiliser. Comme indiqué précédemment, l'une, `mutate()`, conduit à l'ajout d'une variable supplémentaire, l'autre, `summarise()`, définit une procédure d'agrégation de la donnée. Voici une règle simple pour savoir quelle fonction utiliser :

- Si on souhaite résumer une information contenue dans une table, il faut utiliser `summarise()`. Exemple : calculer le nombre total d'équipements pour chaque commune.

  ```{r, eval = FALSE, warning= FALSE}
  bpe_ens_2018_tbl %>%  
    group_by(DEPCOM) %>% 
    summarise(NB_EQUIP_TOT = sum(NB_EQUIP, na.rm = TRUE))
  ```

- Si on souhaite ajouter une information dans une table (en conservant toutes les autres variables), il faut utiliser `mutate()`. Exemple : ajouter dans la table `bpe_ens_2018_tbl` une colonne donnant le nombre total d'équipements pour chaque commune.

  ```{r, eval = FALSE, warning= FALSE}
  bpe_ens_2018_tbl %>%  
  group_by(DEPCOM) %>% 
  mutate(NB_EQUIP_TOT = sum(NB_EQUIP, na.rm = TRUE))
  ```
Avec 'distinct' en fin d'un traitement utilisant 'mutate', on obtient un résumé équivalent à 'summarise'.
```{r, eval = FALSE, warning= FALSE}
# méthode 1 nb exploitations pour la région
nb_ha_sau_2020_reg_a <- exploit_2020 %>% 
  select(nom_dossier,siege_dep,sau_tot) %>% 
  summarise(sau_ha = sum(sau_tot, na.rm = TRUE) ) %>% 
  mutate(territoire = "Pays de la Loire") 

# méthode 2 nb exploitations pour la région
nb_ha_sau_2020_reg_b <- exploit_2020 %>% 
  select(nom_dossier,siege_dep,sau_tot) %>% 
  mutate(territoire = "Pays de la Loire",
         sau_ha = sum(sau_tot, na.rm = TRUE) ) %>% 
  distinct(territoire,sau_ha)

# Réaliser un tableau sommant la livraison de lait de chèvre 
# pour les producteurs des Pays de la Loire 
# pour chaque mois des années 2020 et 2021
# passer la variable 'colldiff' de litre en hectolitre (100l), 
# et mettre le total dans une variable 'livraison'

# En 2 étapes
# étape 1
exploit_laits_mensuel_chevre_pdl <- exploit_laits_mensuel_chevre %>% 
  filter(reg_prod == "PDL") %>% 
  group_by(annee,mois) %>% 
  mutate(livraison=sum(colldiff/100, na.rm = TRUE)) %>% 
  ungroup()

# étape 2
laits_mensuel_chevre_production_pdl <- exploit_laits_mensuel_chevre_pdl %>% 
  distinct(reg_prod,annee, mois,livraison)

# En 1 étape
laits_mensuel_chevre_production_pdl_2 <- exploit_laits_mensuel_chevre %>% 
  filter(reg_prod == "PDL") %>% 
  group_by(annee,mois) %>% 
  summarise(livraison=sum(colldiff/100, na.rm = TRUE)) %>% 
  ungroup()

```

### Somme avec une pondération

```{r , eval = FALSE}
# Somme dans le cas de variable pondérée
# Utilisation de la variable coef_f Coefficient d'extrapolation des données des modules
# Les variables collectées en échantillon uniquement sont suffixées _ech
# mopfamfil_ech : Emploi de la main d'oeuvre familiale de manière permanente
# mopnfamfil_ech : Emploi de la main d'oeuvre non familiale de manière permanente
nb_exploit_2020_mop_fam_reg <- exploit_2020 %>% 
  select(nom_dossier,siege_dep,mopfamfil_ech,mopnfamfil_ech,poids=coef_f) %>% 
  filter(!poids == 0 & mopfamfil_ech == 1) %>% 
  mutate(nb_exploit_mop_fam = sum(poids) ) %>% 
 distinct(nb_exploit_mop_fam)

nb_exploit_2020_mop_non_fam_reg <- exploit_2020 %>% 
  select(nom_dossier,siege_dep,mopfamfil_ech,mopnfamfil_ech,poids=coef_f) %>% 
  mutate(nb_exploit = n() ) %>% 
  filter(!poids == 0) %>% 
  mutate(nb_exploit_ech = n() ) %>%
  filter(mopnfamfil_ech == 1) %>% 
  mutate(nb_exploit_mop_non_fam = sum(poids) ) %>% 
  distinct(nb_exploit,nb_exploit_ech,nb_exploit_mop_non_fam)
```

## Faire des opérations par groupe : `group_by()`
 
**La fonction `group_by()` permet de définir des groupes dans la table de données pour faire des opérations par groupe.** L'utilisation de `group_by()` rend très utiles les opérations avec `summarise()`. Le code suivant groupe les données de la BPE par département `group_by(DEP)` puis calcule le nombre total d'équipements `sum(NB_EQUIP, na.rm = TRUE)` et le nombre total de boulangeries `sum(NB_EQUIP * (TYPEQU == "B203"), na.rm = TRUE)`.
 
```{r , eval = FALSE}
bpe_ens_2018_tbl %>% 
  group_by(DEP) %>%
  summarise(NB_EQUIP_TOT = sum(NB_EQUIP, na.rm = TRUE),
            NB_BOULANGERIES_TOT = sum(NB_EQUIP * (TYPEQU == "B203"), na.rm = TRUE))
```
 
La fonction `group_by` peut également modifier le comportement des fonctions `filter` ou `mutate`, comme pour `summarise`. L'instruction suivante permet ainsi d'ajouter à la BPE une variable égale au nombre total de boulangeries dans le département.

```{r , eval = FALSE}
bpe_ens_2018_tbl %>% 
  group_by(DEP) %>%
  mutate(NB_BOULANGERIES_DEP = sum(NB_EQUIP * (TYPEQU == "B203"), na.rm = TRUE))
```

L'instruction suivante permet de ne conserver que les communes pour lesquelles le nombre d'équipements est le plus important de leur région.

```{r , eval = FALSE}
bpe_ens_2018_tbl %>% 
  group_by(REG) %>%
  filter(NB_EQUIP == max(NB_EQUIP))
```

Ainsi, les opérations à la suite d'un `group_by()`, comme ici `sum` et `max`, sont calculées par groupe de lignes (ici suivant la colonne `DEP`).


On peut aussi directement renommer une variable dans l'opération `group_by()`

```{r , eval = FALSE}
# dimension économique par département
dim_eco_dep <-  exploit_2020 %>% 
  group_by(dep = siege_dep,
           dim = dimeco_coef2017) %>% 
  summarise(n_exploit = n(),
            sau_ha = sum(sau_tot, na.rm = TRUE)) %>% 
  ungroup()
```

::: Remarque

Trois remarques sur l'utilisation de `group_by()` :

- si vous ne savez pas si une table comporte des groupes, vous pouvez afficher la liste des variables de groupe avec la fonction `group_vars()` ;
- si vous appliquez une instruction `group_by()` à une table qui comporte déjà des groupes, alors les groupes sont redéfinis ;
- il est prudent d'appliquer la fonction `ungroup()` à vos données une fois que les opérations par groupe ont été réalisées, afin que les opérations suivantes ne soient pas effectuées par groupe par mégarde.
:::


Avec dplyr 1.1.0, on peut éviter d'utiliser group_by, en utilisant seulement .by :
```{r , eval = FALSE}
library(dplyr)
x %>%  
  summarise(Frequency = sum(Frequency), .by = Category)
```

## Trier un tableau selon des variables

* `arrange()` : trier la table selon une ou plusieurs variables

**Le verbe `arrange()` permet de trier les observations de la table selon une ou plusieurs colonnes.** Par défaut, `arrange` trie par ordre croissant. Il faut utiliser `desc(nom_de_variable)` pour trier par ordre décroissant. Le code suivant trie la BPE selon le code commune et le type d'équipement.

```{r , eval = FALSE}
bpe_ens_2018_tbl %>% 
  arrange(DEPCOM, TYPEQU)
```

Voici quelques utilisations fréquentes de `arrange()` :

| Action                                           | Code                                 |
|--------------------------------------------------|--------------------------------------|
| Trier sur une colonne en ordre croissant         | `arrange(NB_EQUIP)`                  |
| Trier sur plusieurs colonnes en ordre croissant  | `arrange(DEPCOM, NB_EQUIP)`          |
| Trier sur une colonne en ordre décroissant       | `arrange(desc(NB_EQUIP))`            |


```{r , eval = FALSE}
agri_bio_vegetal_fr_tab2 <- agri_bio_vegetal_fr_cultures %>% 
  filter(cultures_2 %not_in% c("autre cas - doublon") ) %>% 
  group_by(annee_2=annee,territoire,cultures_2) %>% 
  summarise(surface_bio_conversion_en_ha=sum(surface_bio_et_en_conversion_en_ha, na.rm = TRUE) ) %>% 
  arrange(desc(territoire),cultures_2)
```

Spécificité pour les vecteurs 'factor', le tri se réalise avec l'instruction levels
```{r , eval = FALSE}
# regroupements et pivot_wider
volailles_sum <- rbind(volailles_dep_sum,volailles_pdl_sum) %>% 
  pivot_wider(names_from=dep,
              values_from =tec_regrpt) %>% 
  mutate(espece_ordre=factor(espece,levels= c("a10-volailles",
                                              "b11-poulets",
                                              "c12-dindes", 
                                              "d14-canards", 
                                              "e17-lapins" ) ) )
```

## Changement ordre des colonnes

relocate
```{r , eval = FALSE}
# la fonction relocate() pour réorganiser les colonnes.
# Le comportement par défaut est de déplacer la ou les colonnes nommées vers la première position.
otex_regroupe <- otex_regroupe %>%
  mutate(otex_lib_det = substr(otex_lib,8,60) ) %>%
  relocate(otex_lib, otex_lib_det, .after = otex_code_regr )

eff_volailles_evol_part <- eff_volailles_evol %>% 
  select(-c(evo_percent,region,an_2020)) %>% 
  pivot_wider(names_from =reg,
              names_prefix='',
              names_sep = "_",
              values_from= c(an_2021,evol_2021_2020) ) %>% 
  mutate(part_pdl_france_2021=paste0(arrondi(an_2021_pdl/an_2021_fm*100,0)," %") ) %>%
  relocate(an_2021_pdl,evol_2021_2020_pdl,an_2021_fm,
           evol_2021_2020_fm,part_pdl_france_2021, .after = espece )

# succession de relocate
lait_chevre_dep_2021_donnees <- lait_chevre_dep3 %>% 
  select(-c(reg_dep_prod,dep_libdep,producteurs_2020_old,livraisons_2020_old,lait)) %>% 
  relocate(Code_département,Département, .before = producteurs_2010) %>% 
  relocate(producteurs_2020,livraisons_2020,
           producteurs_2021,livraisons_2021, .after = livraisons_2019)

```
## Ajout de colonne Total 

sum avec rowwise() au préalable

```{r , eval = FALSE}
# somme de chaque ligne
volailles_pdl_espece_siqo_col <- volailles_pdl_espece_siqo_col %>% 
  rowwise() %>% 
  mutate(autres_siqo=sum(aoc_aop,aut_signe_off,aut_demarche, na.rm = TRUE),
         total_qualite=sum(label_rouge,aoc_aop,agri_bio,aut_signe_off,aut_demarche, na.rm = TRUE))
         
## Pour sum en ligne, il convient d'utiliser rowwise() au préalable
## lorsqu'on souhaite faire un calcul par LIGNE avec des fonctions "vectorielles"
## comme sum, mean ...
## il faut indiquer à R que l'on souhaite un calcul par ligne 
## et non par colonne (calcul par défaut) d'où l'instruction rowwise()
## avant le calcul 

bio_pdl_poires_pommes_abconv_v2 <- bio_pdl_poires_pommes %>% 
  rowwise() %>% 
  mutate(surface_tot=sum(surfab,surfc1,surfc2,surfc3))
  
## calcul surface total bio et conv avec + pour éviter rowwise et sum
surf_bio_pdl_poires_pommes_abconv <- bio_pdl_poires_pommes %>% 
  mutate(surface_tot=surfab+surfc1+surfc2+surfc3) %>% 
  group_by(dep) %>% 
  summarise(surface_ab_conversion=sum(surface_tot)) %>% 
  ungroup()
  
# regroupement par espece
# Ce que nous souhaitons ici, c’est calculer la somme non pas pour l’ensemble du tableau 
# mais pour chaque ligne. 
# Pour cela, on va utiliser la fonction rowwise() : 
# celle-ci est équivalente à un group_by() 
# qui créerait autant de groupes qu’il y a de lignes dans le tableau.
# Quant notre tableau est groupé via un rowwise(), 
# les opérations s’effectuent sur un tableau constitué uniquement de la ligne courante.
# ungroup() pour quitter rowwise()
exploit_volailles_regroupt <- exploit_dont_volailles_2020 %>% 
  rename(eff_05_poulettes=cheptq_711130,
         # eff_03_poulets_chair=cheptq_711140,
         eff_08_autres_volailles=cheptq_719010) %>% 
  rowwise() %>%
  mutate(eff_03_poulets_chair_poules_pondeuses = sum(cheptq_711140,cheptq_711110,
                                                     cheptq_711120, na.rm = TRUE),
         eff_02_dindes = sum(cheptq_711151,cheptq_711152, na.rm = TRUE),
         eff_06_oies = sum(cheptq_711310,cheptq_711330,cheptq_711340,
                           cheptq_711320, na.rm = TRUE),
         eff_01_canards = sum(cheptq_711410,cheptq_711411,
                              cheptq_711421,cheptq_711422, na.rm = TRUE),
         eff_07_pintades= sum(cheptq_711510,cheptq_711520, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(elevage_01_canards=ifelse(eff_01_canards > 0,1,0),
         elevage_02_dindes=ifelse(eff_02_dindes > 0,1,0),
         elevage_03_poulets_chair_poules_pondeuses=ifelse(eff_03_poulets_chair_poules_pondeuses > 0,1,0),
         elevage_05_poulettes=ifelse(eff_05_poulettes > 0,1,0),
         elevage_06_oies=ifelse(eff_06_oies > 0,1,0),
         elevage_07_pintades=ifelse(eff_07_pintades > 0,1,0),
         elevage_08_autres_volailles=ifelse(eff_08_autres_volailles > 0,1,0),
         nb_exploit_01_canards_pdl=sum(elevage_01_canards),
         nb_exploit_02_dindes_pdl=sum(elevage_02_dindes),
         nb_exploit_03_poulets_chair_poules_pondeuses_pdl=sum(elevage_03_poulets_chair_poules_pondeuses),
         nb_exploit_05_poulettes_pdl=sum(elevage_05_poulettes),
         nb_exploit_06_oies_pdl=sum(elevage_06_oies),
         nb_exploit_07_pintades_pdl=sum(elevage_07_pintades),
         nb_exploit_08_autres_volailles_pdl=sum(elevage_08_autres_volailles))
         
```
## Appliquer une fonction dplyr sur un groupe de colonnes : `across()`
 
**La fonction `across()` permet de sélectionner un groupe de colonnes sur lequel on souhaite appliquer une fonction dplyr.** Ainsi on peut appliquer une fonction sur des colonnes en les sélectionnant comme le fait `select()`. Si on souhaite sélectionner des colonnes en fonction de leur type, on utilise en outre `where()`. Le code suivant groupe les données de la BPE avec les deux colonnes dont le nom commence par "DEP", puis effectue la somme de toutes les colonnes de type numérique.
 
```{r , eval = FALSE}
bpe_ens_2018_tbl %>% 
  group_by(across(starts_with('DEP'))) %>%
  summarise(across(where(is.numeric), sum, na.rm = TRUE)) 

```
across()
```{r , eval = FALSE}
# Ajout de la variable livraison_dep_perc (pourcentage par rapport au niveau régional)
lait_production_vache_2 <- lait_production_vache_1 %>% 
  mutate(livraison_dep_perc =  livraison_dep / livraison_reg *100) %>% 
  mutate(across(livraison_dep_perc, ~ arrondi(.,digits=3))) %>% 
  arrange(type,dep_prod)

# Calcul de l'évolution de la production de lait de chèvre et 
# de la collecte de lait de chèvre entre 2020 et 2021, en hl et en %
laits_mensuel_chevre_livr_coll_large_2 <- laits_mensuel_chevre_livr_coll_large_1 %>% 
  mutate(livr2021_evol = livraison_2021 - livraison_2020,
         livr2021_evol_perc = (livraison_2021 / livraison_2020 - 1) *100,
         coll2021_evol = collecte_2021 - collecte_2020,
         coll2021_evol_perc = (collecte_2021 / collecte_2020 - 1) *100) %>% 
  mutate(across(c(livr2021_evol_perc,coll2021_evol_perc), ~ arrondi(.,digits=3))) %>% 
  mutate(across(c(livraison_2020,livraison_2021,collecte_2020,collecte_2021,
                  livr2021_evol,coll2021_evol), ~ arrondi(.,digits=0)))
  
# lait_chevre_mensuel, sélection des 13 premières lignes
lait_chevre <- read.xlsx(xlsxFile=paste0(chemin_entree,fichier_entree), 
                        sheet = "lait chevre",colNames = TRUE,startRow = 8) %>% 
  as_tibble(.name_repair = make_clean_names) %>% 
  slice_head(n=13) %>% 
  mutate(across(-x1, as.numeric) )

produits_laitiers_2021_2 <- produits_laitiers_2021_1b %>% 
  mutate(across(c(finiqte,finiqte1), as.numeric))

# affichage des lignes en doublon pour l'ensemble des variables
bio_pdl_test_doublons <- bio_pdl %>% 
  group_by(across(everything())) %>%
  filter(n()>1) %>%
  ungroup()

```

## Ajouter un préfixe à un nom de variable

```{r , eval = FALSE}
# ajout prefixe annee pour Total
vol_2022 <- vol_2022 %>%
  rename_with(.cols = c(total_nombre,total_poids), function(x){paste0("x2022_", x)})
vol_2021 <- vol_2021 %>%
  rename_with(.cols = c(total_nombre,total_poids), function(x){paste0("x2021_", x)})
```

## Ajouter un suffixe à un nom de variable

```{r , eval = FALSE}
# ajout suffixe annee aux variables
bio_2023 <- read.xlsx(xlsxFile=paste0(chemin,fichier_2023), 
                      sheet = "Feuil1",
                      colNames = TRUE,startRow = 1) %>% 
  as_tibble(.name_repair = make_clean_names) %>%
  rename_with(.cols = c(nombre_dassocies_gaec,quantite_declaree), 
              function(x){paste0(x,"_2023")})
```

## Supprimer un suffixe à un nom de variable

```{r , eval = FALSE}
# enlever le suffixe _Valeur_en_K€
colnames(produits) <- gsub("_valeur_en_k","",colnames(produits))

```

## Regroupement de colonnes

cbind, bind_cols
```{r , eval = FALSE}
# regroupement PDL + France
agri_bio_vegetal_tab1_final <- cbind(agri_bio_vegetal_pdl_tab1_final,agri_bio_vegetal_fr_tab1_final) 
str(agri_bio_vegetal_tab1_final)

# exploitants
exploitants_tot_2020 <- bind_cols(
  mo_2020 %>% 
    summarise(annee = annee_ra_2020,
              nom = "nombre de chefs d'exploitation et coexploitants",
              n_exploit = n() ),
  mo_2020 %>% 
    filter(sex == "FALSE") %>% 
    summarise(femmes = n() ) ) %>% 
    mutate(pcent_f = femmes / n_exploit *100 ) 

```
::: Remarque

La fonction `bind_cols()` permet de juxtaposer des tables (qui doivent avoir le même nombre d'observations). **Il est conseillé d'utiliser cette fonction avec une extrême précaution.** En effet, cette fonction juxtapose les colonnes par position (la première ligne d'une table est juxtaposée à la première de l'autre table), sans aucun contrôle. Si les différentes tables ne sont pas triées de la même façon, la table de sortie sera incohérente. Pour rapprocher deux tables, il est fortement conseillé d'utiliser les fonctions de jointures : `inner_join`, `left_join`, `full_join`... 
:::


# Manipulation d'observations (lignes)

## Ajout de ligne Total 

adorn_totals
```{r , eval = FALSE}
# nb exploitations par département et pour la région
nb_exploit_2020_dep_reg <- exploit_2020 %>% 
  select(nom_dossier,siege_dep) %>% 
  group_by(territoire = siege_dep) %>% 
  summarise(nb_total_exploitations = n() ) %>% 
  ungroup() %>% 
  adorn_totals(where = c("row"), name="Pays de la Loire" )

# ajout ligne Total
nb_exploitants_age_sau_2010_2020 <- exploitants_age_sau_2010_2020 %>% 
  pivot_wider(names_from =annee,
              names_prefix='an_',
              names_sep = "_",
              values_from= c(n_exploit,
                             sau_ha) ) %>% 
  mutate(n_exploit_an_2010_percent = arrondi(n_exploit_an_2010 / sum(n_exploit_an_2010)*100, 2),
         sau_ha_an_2010_percent = arrondi(sau_ha_an_2010 / sum(sau_ha_an_2010)*100, 2),
         n_exploit_an_2020_percent = arrondi(n_exploit_an_2020 / sum(n_exploit_an_2020)*100, 2),
         sau_ha_an_2020_percent = arrondi(sau_ha_an_2020 / sum(sau_ha_an_2020)*100, 2)) %>% 
  adorn_totals(where = c("row"), name="Ensemble" ) %>% 
  relocate(tr_age_10,
           sau_ha_an_2010_percent,
           sau_ha_an_2020_percent,
           sau_ha_an_2010,
           sau_ha_an_2020,
           n_exploit_an_2010_percent,
           n_exploit_an_2020_percent,
           n_exploit_an_2010,
           n_exploit_an_2020)

laits_mensuel_chevre_livr_coll_large <- laits_mensuel_chevre_livr_coll %>% 
  pivot_wider(names_from = annee,
              names_sep = "_",
              values_from = c(livraison,collecte)) %>% 
  adorn_totals(where = "row",
               name = "Total")
               
# à partir du tableau transposé, ajout du total régional
lait_production_vache_large <- lait_production_vache_2 %>% 
  select(-annee) %>% 
  pivot_wider(names_from = type,
              values_from = c(livraison_reg,livraison_dep,livraison_dep_perc)) %>% 
  adorn_totals(where = "row", name = "Pays de la Loire" ) %>% 
  select(-c(starts_with("livraison_reg")))

```

## Filtrer des observations

<center>![](images/filter.png)</center>

* `filter()` : sélectionner des observations selon une ou plusieurs conditions ;

La fonction `filter()` permet de sélectionner les observations, selon une condition (ou plusieurs).

```{r, eval=FALSE}
table_sortie <- filter(table_entree, Condition1, ..., ConditionN)

# Par exemple :
base_filter <- filter(base, DEP == "01" & P14_POP > 10000)

S0 <- filter(selection, DEP == "62")

S1 <- filter(selection, DEP != "62") # tout sauf le 62
S2 <- filter(selection, DEP %in% c("59", "62")) 
S3 <- filter(selection, !(DEP %in% c("59", "62"))) 
S4 <- filter(selection, densite > 100) # l'urbain
S5 <- filter(selection, DEP == "62" & densite > 100) # le PdC urbain
S6 <- filter(selection, DEP == "62" | densite > 100) # le PdC et l'urbain
```

>** Attention à l’opérateur de comparaison : " == " et non pas "="**

filter
```{r , eval = FALSE}
agri_bio_vegetal_fr_tab1 <- agri_bio_vegetal_fr %>%   
  filter(groupe_de_productions %in% c("Toutes productions") ) %>% 
  select(annee,territoire,nombre_de_producteurs,
         surface_bio_et_en_conversion_en_ha,surface_en_conversion_en_ha,surface_bio_en_ha,
         part_bio_de_la_sau_en_percent) %>%  
  mutate(part_bio_sau_plus_percent = paste0(part_bio_de_la_sau_en_percent," %") )

# filtre des exploitations dont la ligne est differente de zero
pa_2020_canards_total_ligne_positif <-  pa_2020_canards_total_ligne %>% 
  filter(!total_ligne == 0)

statut_percent <- statut %>% 
  select(statut_jur="Statut.juridique",an_2010='2010',an_2019='2019',an_2020='2020') %>% 
  filter(statut_jur %not_in% c("Tous statuts") ) %>% 
  mutate(an_2010_percent = arrondi((an_2010/sum(an_2010)*100),2),
         an_2019_percent = arrondi((an_2019/sum(an_2019)*100),2),
         an_2020_percent = arrondi((an_2020/sum(an_2020)*100),2)) 

# exploitants - coexploitants (age) + dim eco 
exploitants_age_dim_hors_micro_2010_2020 <- bind_rows(exploitants_2010,exploitants_2020) %>% 
  filter(dimeco_coef2017 %not_in% c("1-micros"))  %>% 
  group_by(annee = factor(annee, levels = c(annee_ra_2010, annee_ra_2020)),
           tr_age_10) %>%
  summarise(n_exploit = n(),
            .groups = "drop_last")

# Créer le sous-tableau contenant l'établissement de collecte ou le producteur en Pays de la Loire
# Pour des conditions non cumulatives (au moins une des conditions doit être remplie), le ou “|”
laits_mensuel_3 <- laits_mensuel_2 %>% 
  mutate(dep_etab=substr(sircodpost,1,2),
         dep_prod=substr(dep,2,3) ) %>% 
 filter(dep_etab %in% c("44","49","53","72","85") | dep_prod %in% c("44","49","53","72","85"))

```
Autre exemple.
On va ici récupérer les analyses produites par l'ARS

```{r , eval = FALSE}
ars <- filter(prelevement, code_reseau == "ARS")
```

L'exemple ci-dessus n'exerce un filtre que sur une condition unique.

Pour des conditions cumulatives (toutes les conditions doivent être remplies), le `"&"` ou la `","`

```{r , eval = FALSE}
ars <- filter(prelevement, code_reseau == "ARS", code_intervenant == "44")
```

Pour des conditions non cumulatives (au moins une des conditions doit être remplie), le "|"

```{r , eval = FALSE}
ars <- filter(prelevement, code_reseau == "ARS" | code_reseau == "FREDON")
```

Si une condition non cumulative s'applique sur une même variable, privilégier un test de sélection dans une liste avec le `%in%`

```{r , eval = FALSE}
ars <- filter(prelevement, code_reseau %in% c("ARS", "FREDON"))
```

Pour sélectionner des observations qui ne répondent pas à la condition, le `!` (la négation d'un test)

Toutes les observations ayant été réalisées par un autre réseau que l'ARS :

```{r , eval = FALSE}
non_ars <- filter(prelevement, code_reseau != "ARS")
```

Toutes les observations ayant été réalisées par un autre réseau que l'ARS ou FREDON :

```{r , eval = FALSE}
ni_ars_ni_fredon <- filter(prelevement, !(code_reseau %in% c("ARS", "FREDON")))
```

**Le verbe `filter()` permet de sélectionner des observations selon une ou plusieurs conditions logiques.** Voici un exemple de code qui sélectionne les magasins de chaussures (`TYPEQU == "B304"`) dans le premier arrondissement de Paris (`DEPCOM == "75101"`) dans la BPE.

```{r , eval = FALSE}
bpe_ens_2018_tbl %>% 
  filter(DEPCOM == "75101" & TYPEQU == "B304")
```
 
Voici quelques utilisations fréquentes de `filter()` :
 
| Action                                                                | Code                                    |
|-----------------------------------------------------------------------|-----------------------------------------|
| Filtrer sur les modalités qualitatives d'une colonne                  | `filter(DEP %in% c("75", "92"))`  |
| Filtrer sur les modalités quantitatives d'une colonne                 | `filter(NB_EQUIP == 1)`                 |
| Filtrer sur une variable caractère                                    | `filter(str_detect(TYPEQU, "^A"))`      |
| Filtrer sur deux conditions (et)                                      | `filter(DEP == "75" & NB_EQUIP == 1)`   |
| Filtrer sur une alternative (ou)                                      | `filter(DEP == "75" | NB_EQUIP == 1)`   |
| Conserver les observations pour lesquelles la variable est manquante  | `filter(is.na(pop_2016))`               |
| Conserver les observations pour lesquelles la variable est renseignée | `filter( !is.na(pop_2016))`              |

##  Sélection des n premières lignes

slice_head

```{r , eval = FALSE}
# lait_chevre_mensuel, sélection des 13 premières lignes
lait_chevre <- read.xlsx(xlsxFile=paste0(chemin_entree,fichier_entree), 
                        sheet = "lait chevre",colNames = TRUE,startRow = 8) %>% 
  as_tibble(.name_repair = make_clean_names) %>% 
  slice_head(n=13) %>% 
  mutate(across(-x1, as.numeric) ) 
```

## Regroupement de lignes (par exemple pour concaténer deux tables)

Le package `dplyr` propose la fonction `bind_rows()` pour superposer deux ou plusieurs tables (en empilant des observations). Deux remarques sur l'utilisation de cette fonction :

- `bind_rows()` combine les tables en fonction du nom des colonnes, l'ordre des colonnes n'a pas donc d'importance
- si une colonne est manquante dans une des tables, alors des valeurs manquantes sont générées dans la table de sortie.

```{r , eval = FALSE}
# 1- Dans ce tableau ne conserver que l'année, le département de la production, 
# le type (VB et VNB), les totaux départementaux et régionaux
lait_production_vache_type <- exploit_lait_production_vache_type %>%
  group_by(type) %>%
  mutate(livraison_reg=sum(colldiff, na.rm=TRUE)) %>%
  ungroup() %>% 
  group_by(type,dep_prod) %>% 
  mutate(livraison_dep=sum(colldiff, na.rm=TRUE)) %>%
  ungroup() %>% 
  distinct(annee,dep_prod,type,livraison_reg,livraison_dep)
  
# 2- Réaliser un tableau similaire pour l'ensemble des vaches 
# (sans distinguer VB et VNB, en indiquant type="vache")
lait_production_vache_ensemble <- lait_production_vache_1 %>%
  mutate(type="vache",
         livraison_reg=sum(colldiff / 100, na.rm=TRUE)) %>%
  group_by(dep_prod) %>% 
  mutate(livraison_dep=sum(colldiff / 100, na.rm=TRUE)) %>%
  ungroup() %>% 
  distinct(annee,dep_prod,type,livraison_reg,livraison_dep)

# 3- Regrouper les 2 tableaux agrégés : tableau pour l'ensemble des vaches 
# + tableau distinguant VB et VNB
lait_production_vache <-  bind_rows(lait_production_vache_ensemble,lait_production_vache_type) 

# statut
statut_percent <- statut %>% 
  select(statut_jur="Statut.juridique",an_2010='2010',an_2019='2019',an_2020='2020') %>% 
  filter(statut_jur %not_in% c("Tous statuts") ) %>% 
  mutate(an_2010_percent = arrondi((an_2010/sum(an_2010)*100),2),
         an_2019_percent = arrondi((an_2019/sum(an_2019)*100),2),
         an_2020_percent = arrondi((an_2020/sum(an_2020)*100),2)) 

statut_complet <- statut_percent %>% 
  bind_rows(statut %>% 
              select(statut_jur="Statut.juridique",an_2010='2010',an_2019='2019',an_2020='2020') %>% 
              filter(statut_jur %in% c("Tous statuts") ) %>% 
              mutate(an_2010_percent = 100,an_2019_percent = 100,an_2020_percent = 100)  
  )

# agrégation données
emploi_salarie <- bind_rows(a_agri_long, b_iaa_long,cz_ind_tot_long,d_constr_long,
                            e_commerce_long,fz_serv_march_tot_long,fz_serv_non_march_tot_long)

# regroupement PDL + France 2021
groupe_produits_laitiers_2021 <- bind_rows(groupe_produits_laitiers_2021_France,
                                           groupe_produits_laitiers_2021_PDL)

# regroupements de lignes possibles aussi avec rbind
volailles_sum <- rbind(volailles_dep_sum,volailles_pdl_sum)

```
## Ajout d'une ligne

```{r , eval = FALSE}
# ajout 0 pour R52 pour RUB144500	Fromages de vache à pâte persillée     
produits_laitiers_2021_1b <- produits_laitiers_2021_1 %>% 
  add_row(sir_regn=52,rub="144500",
          lib="Fromages de vache à pâte persillée",
          finiqte=0,finiqte1=0,nbfiniqte=0,nbfiniqte1=0)
```

# Transposition

Les deux principales opérations de restructuration des données peuvent être illustrées par les deux transformations suivantes :

* **Transformation *wide to long* ** : 

![Transformation *wide to long*](./images/widetolong.png){width=80%}

* **Transformation *long to wide* ** : 

![Transformation *long to wide*](./images/longtowide.png){width=80%}


## Transposition de colonnes en lignes (plus de lignes)

`pivot_longer` : transformer des colonnes en lignes

La fonction `pivot_longer` permet de restructurer des données en transformant des colonnes en lignes. Cette fonction prend quatre arguments principaux :

- le `data.frame` (ou le `tibble`) auquel elle est appliquée ;
- `cols` : un vecteur contenant le nom des colonnes dont les valeurs vont être transposées ;
- `names_to` : le nom de la nouvelle colonne qui va contenir les noms des colonnes transposées ;
- `values_to` : le nom de la nouvelle colonne qui va contenir les valeurs des colonnes transposées.


```{r , eval = FALSE}
library(tidyr) # pour pivot

# pivot_longer
# colonnes donnees en ligne
agri_bio_vegetal_fr_tab1_long <- agri_bio_vegetal_fr_tab1_car %>%   
  pivot_longer(cols=c("nombre_de_producteurs","surface_bio_et_en_conversion_en_ha",
                      "surface_en_conversion_en_ha","surface_bio_en_ha",
                      "part_bio_sau_plus_percent"),
               names_to = c("vegetal"),
               values_to = "donnees" ) %>% 
  arrange(desc(territoire) )

# colonne espece en ligne
volailles_pdl_espece <- volailles_pdl_siqo2 %>%   
  pivot_longer(cols=starts_with("espece_"),
               names_to = c("espece","siqo"),
               names_sep = "_siqo_",
               names_prefix="espece_",
               values_to = "tec" )
volailles_pdl_espece <- volailles_pdl_espece %>% 
  mutate(tec=tec/1000)

# nouvelles variables mois, type(avec nombre, poids) en enlevant suffixe mois, type par transposition
vol_2022 <- vol_2022 %>%   
             pivot_longer(cols = starts_with('x2022'), 
                          names_prefix = "x2022_", 
                          names_to = c("mois", "type"), 
                          names_sep = "_",
                          values_to = "effectif")
  
# un seul montant en colonne
# nouvelle variable 'montant' en mettant la liste des montants par trimestre par transposition
# crée variables "trimestre"(modalités 'x1','x2','x3','x4') et 
# "annee" à partir de c('x4t2018','x1t2019'...)  
produits_long <- produits %>%   
             pivot_longer(cols = c('x4t2018','x1t2019','x2t2019','x3t2019','x4t2019',
                                   'x1t2020','x2t2020','x3t2020','x4t2020',
                                   'x1t2021','x2t2021','x3t2021','x4t2021',
                                   'x1t2022','x2t2022','x3t2022'), 
                          names_to = c("trimestre","annee"),
                          names_sep = "t",
                          values_to = "montant")

# une seule espece en colonne
# nouvelle variable espece en mettant la liste des especes par transposition
itavi_2022_2021_espece <- itavi_2022_2021 %>%   
             pivot_longer(cols = c(poulet_standard,poulet_label_rouge,dinde,pintade,
                                   poule_pondeuse,canard_rotir,canard_gras,lapin,
                                   poulet_label_rouge_non_ogm,poule_pondeuse_label_rouge_non_ogm), 
                          names_to = c("espece"),
                          values_to = "indice")

# colonnes donnees en ligne
# names_pattern = "(.*)_dep" pour enlever suffixe "_dep"
# names_pattern = paste0("(.*)_", suffixe)
agreg_anim_produit_petit_dep_1 <- agreg_anim_produit_petit_pdl %>% 
  select(-contains("reg")) %>% 
  pivot_longer(cols=contains("_dep"),
               names_to = "indicateur",
               values_to = "donnees_dep",
               names_pattern = "(.*)_dep")
```


Nous souhaitons obtenir une nouvelle table, avec une observation par EPCI et par tranche d'âge. Voici le code qui permet d'obtenir cette table : on transpose les valeurs des colonnes dont le nom commence par "TP" (`cols = starts_with("TP")`), le nom des colonnes transposées sera indiquée dans la nouvelle colonne "tranche_age" (`names_to = "tranche_age"`) et les valeurs des colonnes transposées seront indiquées dans la colonne "taux_pauvrete" (`values_to = "taux_pauvrete"`).


```{r , eval = FALSE}
donnees_pauvrete_long <- filosofi_epci_2016_tbl %>% 
  pivot_longer(cols = starts_with("TP"), 
               names_to = "tranche_age", 
               values_to = "taux_pauvrete")
```


## Transposition de lignes en colonnes (plus de colonnes)

 `pivot_wider` : transformer des lignes en colonnes

La fonction `pivot_wider` permet de restructurer des données en transformant des lignes en colonnes. Cette fonction prend quatre arguments principaux :

- le `data.frame` (ou le `tibble`) auquel elle est appliquée ;
- `id_cols` : un vecteur contenant le nom des colonnes qui définissent les observations de la table transposée ;
- `names_from` : un vecteur contenant le nom de la (ou des) colonne(s) qui donne(nt) les noms des nouvelles colonnes ;
- `values_from` : un vecteur contenant le nom de la (ou des) colonne(s) dont les valeurs vont être transposées.

Par ailleurs, l'option `names_prefix` permet de définir le préfixe du nom des nouvelles colonnes, ce qui est utile pour avoir des noms explicites.

```{r , eval = FALSE}
library(tidyr) # pour pivot

bpe_ens_2018_tbl %>%
	group_by(REG, TYPEQU) %>%
	summarise(NB_EQUIP_TOT = sum(NB_EQUIP)) %>%
	pivot_wider(id_cols =TYPEQU,  
	            names_from = REG, 
	            values_from = NB_EQUIP_TOT, 
	            names_prefix = "nb_equip_reg")

# pivot_wider
volailles_sum <- rbind(volailles_dep_sum,volailles_pdl_sum) %>% 
  pivot_wider(names_from=dep,
              values_from =tec_regrpt) 

# transposition lignes vers colonnes
produits_a17_large <- produits_a17 %>%
   pivot_wider(names_from = c(annee,flux,semestre), 
               values_from = valeur, 
               names_prefix = "an_"
               ) %>%
   mutate(an_2021_imports = an_2021_I_sem1 + an_2021_I_sem2,
          an_2022_imports = an_2022_I_sem1 + an_2022_I_sem2,
          an_2021_exports = an_2021_E_sem1 + an_2021_E_sem2,
          an_2022_exports = an_2022_E_sem1 + an_2022_E_sem2,
          .after=a17_lib_detail)

# territoire en colonne 
agri_bio_vegetal_fr_tab1_final <- agri_bio_vegetal_fr_tab1_long %>%   
  pivot_wider( names_from = "territoire", 
               names_prefix="",
               values_from = "donnees" ) 

# Transposer le tableau en format plus large, à partir de la variable type
lait_production_vache_large <- lait_production_vache_2 %>% 
 pivot_wider(names_from = type,
             values_from = c(livraison_reg,livraison_dep,livraison_dep_perc))

# Le format large est approprié pour calculer des évolutions
# Calculer l'évolution de la production de lait et de la collecte de lait 
# entre 2020 et 2021, en hl et en %
laits_mensuel_chevre_livr_coll_large_2 <- laits_mensuel_chevre_livr_coll_large_1 %>% 
  mutate(livr2021_evol = livraison_2021 - livraison_2020,
         livr2021_evol_perc = (livraison_2021 / livraison_2020 - 1) *100,
         coll2021_evol = collecte_2021 - collecte_2020,
         coll2021_evol_perc = (collecte_2021 / collecte_2020 - 1) *100) %>% 
  mutate(across(c(livr2021_evol_perc,coll2021_evol_perc), ~ arrondi(.,digits=3))) %>% 
  mutate(across(c(livraison_2020,livraison_2021,
                  collecte_2020,collecte_2021,livr2021_evol,coll2021_evol), ~ arrondi(.,digits=3)))
  
# colonne an_mois en colonne
oeufs_2022_2021_an_mois <- oeufs_2022_2021 %>%   
             pivot_wider( names_from = c(Année,mois),
                          names_prefix="an_",
                          values_from = c(Exportation_Nombre,Importation_Nombre,solde) )

eff_volailles_evol_part <- eff_volailles_evol %>% 
  select(-c(evo_percent,region,an_2020)) %>% 
  pivot_wider(names_from =reg,
              names_prefix='',
              names_sep = "_",
              values_from= c(an_2021,evol_2021_2020) ) %>% 
  mutate(part_pdl_france_2021=paste0(arrondi(an_2021_pdl/an_2021_fm*100,0)," %") ) %>%
  relocate(an_2021_pdl,evol_2021_2020_pdl,an_2021_fm,evol_2021_2020_fm,
           part_pdl_france_2021, .after = espece )

laits_mensuel_chevre_livr_coll_large <- laits_mensuel_chevre_livr_coll %>% 
  pivot_wider(names_from = annee,
              names_sep = "_",
              values_from = c(livraison,collecte)) %>% 
  adorn_totals(where = "row",
               name = "Total")

# passage au format large pour dep
exploit_otex_dep <- exploit_pdl %>%
  arrange(desc(dep),otex_regroup) %>% 
  pivot_wider(id_cols =otex_regroup,  
              names_from = dep, 
              values_from = c03_n_exploit_dep, 
              names_prefix = "dep_")

# on transpose cult_pdl_2020 pour avoir une seule ligne par exploitation (nom_dossier)
nom_dossier_cult_pdl <- cult_pdl_2020 %>% 
  pivot_wider(id_cols = nom_dossier,  
              names_from = cult_ra_code, 
              values_from = c(cultsur,irrisur), 
              names_prefix = "")

# enchainement de pivots
otex_regroupe <- otex_transp  %>% 
  select(-c(ends_with('temp'),otex_4813,otex_4840,otex_5100,otex_5374) ) %>% 
  pivot_longer(cols = -c(annee), 
               names_to = c("otex_code_regr"),
               values_to = "etp") %>% 
  pivot_wider(names_from =annee,
              values_from= c(etp) )

# on remet temporairement import export en colonne pour calculer le solde
produits_large <- produits_long_AZ_C1 %>%   
   pivot_wider( names_from = flux, 
                values_from = montant) %>% 
   mutate(solde = Export - Import)
produits_long_AZ_C1 <- produits_large %>%   
             pivot_longer(cols = c('Export','Import','solde'), 
                          names_to = 'flux',
                          values_to = "montant")

```
# Jointure de tableaux

Les noms de variables peuvent être cités sans guillemets (sauf dans le cas des jointures).
-   les fonctions `*_join(x, y, by)` du package `dplyr` permettent de joindre les tables `x` et `y` sur les variables de jointure précisées dans l'argument `by`.
Les variables non jointives portant le même nom sont suffixées par .x et par .y (par défaut).

## Jointure à gauche avec left_join

Dans une jointure à gauche, on adjoint aux informations de la table de gauche les informations issues de la table de droite.

<center>![](images/left_join.png){width=50%}</center>

Ainsi, c'est le tableau de gauche qui définit les individus du tableau en sortie (quand bien-même il n'y a pas d'information à leur sujet dans le tableau de droite : on remarque ainsi la donnée manquante dans la colonne D pour le 3e individu).
La fonction s'appuie sur les variables communes aux deux tableaux (ici A et B), qui permettent d'identifier les individus et de relier les informations des deux tables.
On précise explicitement quelles sont les identifiants qui permettent de faire ce lien entre les deux tables, à travers l'argument by :

```{r , eval = FALSE}
left_join(x,y, by=c("A","B"))
```

```{r , eval = FALSE}
# jointure des tableaux exploit et prod_anim, avec nom_dossier
exploit_anim <- exploit %>% 
  left_join(prod_anim,
          by ="nom_dossier")

# ajout au fichier historique des années 2020 et 2021
lait_chevre_historiq <- lait_chevre3  %>%
  left_join(laits_mensuel_chevre_livr_coll_large,
            by="code_mois") 

oeufs_annee <- oeufs_2021  %>%
  left_join(oeufs_2020,
            by = c("reg","libelle_culture") )

laits_mensuel_chevre_livr_coll <- laits_mensuel_chevre_livraison %>% 
  left_join(laits_mensuel_chevre_collecte,
            by=c("annee","code_mois")) %>% 
  select(-c(reg_etab,reg_prod))

# ajout au fichier historique des années 2020 et 2021
produits_laitiers_historiq <- produits_laitiers  %>%
  left_join(groupe_produits_laitiers_2021 %>% 
              select(-libellé_produit),
            by=c("territoire","code_produit") )

# regroupement dep reg  avec left_join 
agreg_anim_produit_petit_dep_reg <- agreg_anim_produit_petit_dep_2 %>% 
  left_join(agreg_anim_produit_petit_reg, 
            by = "indicateur") %>% 
  mutate(across(where(is.numeric), ~ round_half_up(.,digits=0)))

# on enleve avec collectiffil les pacages communs (Brière par exemple)
exploit_2010 <- exploit_2010_fm %>% 
  left_join(ra_2010_geo_2020 %>%
              select(id_dossier,
                     siege_dep_2020,       
                     siege_reg_2020),
              by = c("id_dossier") )  %>% 
  filter(siege_reg_2020 == "52" & collectiffil == "0") 

# enchainement de left_join
exploitants_2010 <- fam_2010 %>% 
  filter(famlien %in% c("10", "11", "12", "13"))  %>% 
  mutate(nom_dossier = id_dossier,
         annee = annee_ra_2010,
         age = annee_ra_2010 - as.integer(famanais), 
         tr_age_10 = cut(age, c(0, seq(40, 60, by = 10), Inf), right = FALSE ) ) %>% 
  left_join(exploit_2010 %>% 
              mutate(sau_tot = sau / 100) %>% 
              select(nom_dossier = id_dossier,
                     sau_tot), 
             by = "nom_dossier") %>% 
  left_join(pbs_2010 %>% 
              select(nom_dossier = id_dossier,
                     dimeco_coef2017,
                     pbstot_coef17), 
            by = "nom_dossier")

# on ajoute le libelle des nomenclatures a129, cpf4 et a17
produits <- produits %>% 
   left_join(y = a129, 
             by = "a_129") %>% 
   left_join(y = cpf4, 
             by = "cpf4") %>% 
   left_join(y = table_NAF, 
             by = "a_129") %>% 
   left_join(y = secteur_a17, 
             by = "a_17")

```


**Avec `dplyr`, les jointures se réalisent grâce aux fonctions `left_join`, `right_join`, `inner_join`, `full_join` et `anti_join`.** Ces fonctions prennent les arguments suivants :
  
- le nom des deux `data.frame` à joindre ;
- les variables de jointure, défini par l'argument `by`. Lorsque la variable de jointure ne porte pas le même nom dans les deux tables, on utilise le paramètre `by = c("var_x" = "var_y")`. S'il y a plusieurs variables de jointures, on écrit `by = c("var_x1" = "var_y1", "var_x2" = "var_y2")`.

Il est préférable d'utiliser ces fonctions sur des objets `tibble` plutôt que `data.frame`. On va donc convertir les deux tables avant de présenter un exemple :

```{r , eval = FALSE}
library(dplyr)
filosofi_com_2016_tbl <- as_tibble(doremifasolData::filosofi_com_2016)
cog_com_2019_tbl <- as_tibble(doremifasolData::cog_com_2019)
```

Voici un exemple dans lequel on utilise la fonction `left_join` pour réaliser une jointure à gauche entre la table des données Filosofi et la table des communes du COG.

```{r , eval = FALSE}
table_jointe_tbl <- filosofi_com_2016_tbl %>% 
left_join(y = cog_com_2019_tbl, 
by = c("CODGEO" = "com"))
head(table_jointe_tbl)
```

Parfois, il peut être utile de réaliser une jointure de la table avec elle-même pour affecter la valeur d'une variable à une autre variable. Dans l'exemple suivant, on affecte le nom du premier département à l'ensemble des lignes.
```{r , eval = FALSE}
# ajout du rang 1 (département) à l'ensemble des lignes
# on réalise une jointure de la table avec elle-même pour affecter la valeur d’une variable # à une autre variable. 
# Dans l’exemple suivant, on affecte la valeur (le 1er dep) de valeur_dep_rang1 
# relative à valeur_dep_rang==1.
# on prend valeur_dep_rang1 correspondant au dep du rang1 (pour valeur_dep_rang == 1) 
# et on affecte la valeur 
# pour l'ensemble des cas 
# jointure de l'ensemble des lignes avec la ligne contenant valeur_dep_rang1 (le 1er dep) 
# ligne par ligne
recolte_bois_dep_reg <-  recolte_bois_dep_reg %>% 
  mutate(commun = 1) 

# en 2 étapes
recolte_bois_dep_reg_rang1_etape1 <-  recolte_bois_dep_reg %>%
  select(categorie,commun,
         valeur_dep_rang_y=valeur_dep_rang,
         valeur_dep_rang1=valeur_dep_rang1_a) %>%
  filter(valeur_dep_rang_y == 1)

recolte_bois_dep_reg_2_etape2 <-  recolte_bois_dep_reg %>%
  left_join(recolte_bois_dep_reg_rang1_etape1,
            by=c("categorie","commun")) %>% 
  select(-c(valeur_dep_rang1_a,valeur_dep_rang_y))

# en une étape
recolte_bois_dep_reg_2 <-  recolte_bois_dep_reg %>%
  left_join(recolte_bois_dep_reg %>% 
              select(categorie,commun,
                     valeur_dep_rang_y=valeur_dep_rang,
                     valeur_dep_rang1=valeur_dep_rang1_a) %>%
              filter(valeur_dep_rang_y == 1),
            by=c("categorie","commun")) %>% 
  select(-c(valeur_dep_rang1_a,valeur_dep_rang_y))

```

Utilisation de la numérotation de lignes comme identifiant commun pour la concaténation d'une table avec une sous-table.

```{r , eval = FALSE}
# jointure des tableaux bio_pdl et bio_pdl_pommes,
# avec l'identifiant “numéro de ligne”

# Ajout d’une colonne “numéro de ligne”
# creation d'une variable identifiant reprenant le numéro de ligne 
bio_pdl_numero_ligne <- bio_pdl %>% 
  mutate(ident=row.names(bio_pdl), .before=1)

# Filtrer les enregistrements concernant les pommes
bio_pdl_pommes_2 <- bio_pdl_numero_ligne %>% 
  mutate(libelle_ab_2 = ifelse(startsWith(libelleonab, "Pomme"), "Pommes", libelleonab)) %>% 
  filter(libelle_ab_2 %in% c("Pommes") & libelleonab != "Pommes de terre (hors féculière)")

# jointure des tableaux bio_pdl_numero_ligne et bio_pdl_pommes_2,
bio_pdl_nomenclature_numero_ligne <- bio_pdl_numero_ligne %>% 
  left_join(bio_pdl_pommes_2 %>% 
              select(ident,libelle_ab_2),
            by = "ident")
recolte_bois_pdl_indic <- recolte_bois_pdl_indic %>%
  mutate(identifiant=row.names(recolte_bois_pdl_indic), .before=1) %>% 
  mutate(identifiant = as.numeric(identifiant) + 10)

recolte_bois_pdl_indic <- recolte_bois_pdl_indic %>%
  mutate(identifiant = case_when(
    indicateur == "Récolte de bois" ~ 62,
    TRUE ~ identifiant), 
    .before=1)

```

## Jointure complète avec full_join


Dans le cas d'une jointure complète, au contraire d'une jointure interne, on conserve l'ensemble des individus décrits par l'un ou l'autre des jeux de données.

<center>![](images/full_join.png){width=50%} </center>

```{r , eval = FALSE}
full_join(x,y,by=c("A","B"))
```

Identifiants portant des noms différents

Il arrive qu'une variable identifiant les individus n'ait pas le même nom dans les deux tableaux. Dans ce cas on peut préciser de faire correspondre à une variable du premier tableau, une autre variable du deuxième tableau, de la manière suivante:

```{r , eval = FALSE}
# Fait correspondre x$C et y$D:
full_join(x,y,by=c("C"="D"))
```

```{r , eval = FALSE}
# jointure des tableaux, avec pacage
surface_bio_2022_2023 <- bio_2023 %>% 
  full_join(bio_2022,
          by ="pacage") 

# creation indicatrice 
# present_2023_present_2022
# present_2023_absent_2022
# absent_2023_present_2022
# creation variable surface supplémentaire en 2023
surface_bio_2022_2023 <- surface_bio_2022_2023 %>% 
  mutate(present_2023_present_2022 = ifelse(!is.na(quantite_declaree_2023) & !is.na(quantite_declaree_2022),
                                            yes = 1, no = 0),
         present_2023_absent_2022 = ifelse(!is.na(quantite_declaree_2023) & is.na(quantite_declaree_2022),
                                            yes = 1, no = 0),
         absent_2023_present_2022 = ifelse(is.na(quantite_declaree_2023) & !is.na(quantite_declaree_2022),
                                            yes = 1, no = 0),
         indicateur_presence = case_when(
           !is.na(quantite_declaree_2023) & !is.na(quantite_declaree_2022) ~ "present_2023_present_2022",
           !is.na(quantite_declaree_2023) & is.na(quantite_declaree_2022) ~ "present_2023_absent_2022",
           is.na(quantite_declaree_2023) & !is.na(quantite_declaree_2022) ~ "absent_2023_present_2022",
         TRUE ~ "autre"),
         surface_supplementaire_2023 = quantite_declaree_2023 - quantite_declaree_2022)

unique(surface_bio_2022_2023$indicateur_presence)
```

```{r , eval = FALSE}
# jointure des tables des différents millésimes et de la table de passage
# plusieurs lignes par commune en geo 2022 
# filtre pour récupérer uniquement les communes des Pays de la Loire
pop <- pop_1990 %>% 
  full_join(pop_1999, by = c("COM")) %>%
  full_join(pop_2010, by = c("COM")) %>%
  full_join(pop_2019, by = c("COM")) %>%
  full_join(comdepuis1943_com2022, by = c("COM"="depcom_initial")) %>%
  filter(dep_2022 %in% c("44","49","53","72","85")) %>%
  select(depcom_2022,libcom_2022,PSDC90,PSDC99,PMUN10,PMUN19)
```


## Quelques bonnes pratiques sur les jointures
Pour plus de précisions, consulter la fiche https://www.book.utilitr.org/03_fiches_thematiques/fiche_joindre_donnees#jointure-avec-dplyr qui présente un certain nombre de règles et de bonnes pratiques sur les jointures.

### Avant la jointure

Avant de procéder à une jointure, il est essentiel de **vérifier la qualité des identifiants dans les deux tables** que l'on souhaite joindre.

- **Règle n°1 : vérifier la présence de valeurs manquantes dans les variables de jointure**.

  Une première approche consiste à rechercher les valeurs manquantes (`NA`) dans les variables de jointure. Le code suivant permet de calculer le nombre d'observations pour lesquelles l'identifiant est manquant :

  ```{r, eval=FALSE}
  sum(is.na(filosofi_com_2016$CODGEO))
  sum(is.na(cog_com_2019$com))
  ```
  
  Il convient de vérifier que les variables de jointure ne contiennent aucun `NA` dans les deux tables. Toutefois, les valeurs manquantes peuvent prendre des formes plus complexes que `NA` : `0`, `.`, `999`... c'est pourquoi il est important de procéder à une inspection visuelle des variables de jointure. Pour ce faire, on peut utiliser la fonction `unique()`, qui permet d'afficher la liste des valeurs qui apparaissent dans une variable.

  ```{r, eval=FALSE}
  unique(filosofi_com_2016$CODGEO)
  ```

- **Règle n°2 : vérifier la présence de doublons dans les variables de jointure**.

  Si les variables de jointure contiennent un grand nombre de fois les mêmes valeurs, la jointure peut devenir très gourmande en ressources, voire irréalisable. Il est donc indispensable de repérer les doublons, et de les traiter si nécessaire. Les deux codes suivants calculent le nombre d'observations dans la table pour chaque valeur des variables de jointure, et affichent les premières lignes par nombre d'observations décroissant. Si la variable `nb_obs` est supérieure ou égale à 2, alors il y a des doublons.

  ```{r, eval=FALSE}
  doublons <- filosofi_com_2016_tbl %>% 
                group_by(CODGEO) %>% 
                summarise(nb_obs = n()) %>% 
                filter(nb_obs > 1) %>% 
                arrange(-nb_obs)
  doublons
  ```
  Une présence de doublons rend nécessaire une analyse de la table avant de réaliser la jointure. 

Le fait que les variables de jointure contiennent des valeurs manquantes ou des doublons n'est pas nécessairement un problème. C'est à vous de déterminer si cela pose un problème. Voici deux questions que vous pouvez vous poser pour analyser la situation :

- La (ou les) variable(s) de jointure doi(ven)t-elle(s) impérativement être renseignée(s) pour chaque observation ? Si oui, il ne doit pas y avoir de valeurs manquantes.
- La (ou les) variable(s) de jointure doi(ven)t-elle(s) identifier de façon unique chaque observation ? Si oui, il ne doit pas y avoir de doublons.

`Vérification de doublons de lignes` 

Cette vérification peut permettre de déterminer les variables servant d'identifiant commun à 2 tables.
On peut aussi utiliser la numérotation de lignes comme identifiant commun pour la concaténation d'une table avec une sous-table.

```{r , eval = FALSE}
# afficher les lignes en doublon pour l'ensemble des variables
bio_pdl_test_doublons <- bio_pdl %>% 
  group_by(across(everything())) %>%
  filter(n()>1) %>%
  ungroup()

# afficher les lignes en doublon pour l'ensemble des variables servant d'identifiant
bio_pdl_test_doublons_var_ok <- bio_pdl %>% 
  group_by(raisonsociale,numeropacage,numerobio,libelleonab,ss_groupe_onab_libelle,nomoc) %>%
  filter(n()>1) %>%
  arrange(raisonsociale,numeropacage,numerobio,libelleonab,ss_groupe_onab_libelle,nomoc) %>%
  ungroup()

# afficher les lignes en doublon pour l'ensemble des variables servant d'identifiant sans nomoc
# il reste 11 lignes en double, soit 22 observations
bio_pdl_test_doublons_var_doubl <- bio_pdl %>% 
  group_by(raisonsociale,numeropacage,numerobio,libelleonab,ss_groupe_onab_libelle) %>%
  filter(n()>1) %>%
  arrange(raisonsociale,numeropacage,numerobio,libelleonab,ss_groupe_onab_libelle) %>%
  ungroup()
  
```

- **Règle n°3 : vérifier la compatibilité des variables de jointure**. 
  
  - **Une jointure ne peut être réalisée avec `R` que si les variables de jointure sont de même type.** Il faut donc vérifier que c'est le cas. Les types de variables les plus fréquemment utilisées pour des jointures avec `R` sont `integer` (nombre entier), `character` (chaîne de caractères) et `factor` (catégorie). On peut utiliser la fonction `class` pour connaître le type d'une variable. 
  
  ```{r, eval=FALSE}
  # Type de la variable de jointure dans la table Filosofi
  class(filosofi_com_2016$CODGEO)
  # Type de la variable de jointure dans le COG 2019
  class(cog_com_2019$com)
  ```
  Si les variables sont de type différent, alors il faut convertir les variables de jointure dans l'une des tables. Pour ce faire, on peut utiliser les fonctions `as.integer`, `as.character` et `as.factor`.
  
  Pour afficher le nombre d'identifiants distincts dans une table. 
  ```{r, eval=FALSE}
  # Nombre d'identifiants distincts dans la table Filosofi
  length(unique(filosofi_com_2016$CODGEO))
  ```

### Après la jointure

Après une jointure, il est essentiel de **vérifier que la jointure a bien produit le résultat attendu**.

- **Règle n°4 : vérifier que le nombre d'observations de la table de sortie est cohérent.** 

  Par exemple, dans le cas d'une jointure à gauche (_left join_) et si les variables de la table de droite ne présentent aucun doublon, alors la table de sortie doit avoir le même nombre d'observations que la table de gauche. 

  ```{r, eval=FALSE}
  dim(filosofi_com_2016_tbl)
  table_jointe_tbl <- left_join(x = filosofi_com_2016_tbl, 
                                y = cog_com_2019_tbl, 
                                by = c("CODGEO" = "com"))
  dim(table_jointe_tbl)
  ```

- **Règle n°5 : vérifier la présence éventuelle de valeurs manquantes (`NA`) dans les variables d'intérêt.** 

  On peut par exemple utiliser la fonction `is.na()` qui permet de repérer les observations manquantes dans les variables provenant de la table de droite. S'il y a des valeurs manquantes, cela peut indiquer que cette variable contient des valeurs manquantes dans la table de droite, ou que certaines observations de la table de gauche n'ont pas de correspondances dans la table de droite.

  ```{r, eval=FALSE}
  table_jointe_tbl %>% filter(is.na(dep))
  ```
  
## Compléments sur les différentes jointures

Le graphique ci-dessous illustre les différentes méthodes de jointure :

| **Type de jointure** | **Exemple** |
| :--------------------------------------------------: | :----------------------------------------------: |
| Jointure interne (_inner join_) |![](images/Manipuler_donnees_dplyr/inner_join.png){width=90%} 
| Jointure à gauche (_left join_) |![](images/Manipuler_donnees_dplyr/left_join.png){width=90%} 
| Jointure à droite (_right join_) |![](images/Manipuler_donnees_dplyr/right_join.png){width=90%} 
| Jointure externe (_full join_) |![](images/Manipuler_donnees_dplyr/full_join.png){width=90%} 

***
`full_join`

**Les lignes de chacune des tables abondent la fusion.**

![*Comportement d'un full_join*](images/apercu_full_join.png){fig-align="center"}

***
`inner_join`

**Seules les lignes aux identifiants communs abondent la fusion.**

![*Comportement d'un inner_join*](images/apercu_inner_join.png){fig-align="center"}

***
`left_join`

**Les lignes de la première table sont conservées et sont abondées par les lignes de la deuxième table qui partagent les mêmes identifiants.**

![*Comportement d'un left_join*](images/apercu_left_join.png){fig-align="center"}

***
`right_join`

**Les lignes de la seconde table sont conservées et sont abondées par les lignes de la première table qui partagent les mêmes identifiants.**

![*Comportement d'un right_join*](images/apercu_right_join.png){fig-align="center"}

***
`anti_join`

**Seules les lignes de la première table dont les variables identifiantes n'apparaissent pas dans la seconde table sont conservées.**

![*Comportement d'un anti_join*](images/apercu_anti_join.png){fig-align="center"}

***
`semi_join`

**Seules les lignes de la première table dont les variables identifiantes apparaissent dans la seconde table sont conservées.**

![*Comportement d'un semi_join*](images/apercu_semi_join.png){fig-align="center"}

***

<br>

# Foire aux questions

## Où trouver de la documentation ?

utilitR 
https://www.book.utilitr.org/

Ministère de la Transition écologique et de la Cohésion des territoires
https://mtes-mct.github.io/parcours-r/

Ces 2 sites servent de source pour alimenter le présent document.

Les lettres du groupe des utilisateurs de R (GUR) sont aussi très utiles :

`Comment fai'R pour ajouter des 0 manquants en début de chaîne ?`

`Comment fai'R pour choisir la bonne fonction de jointure ?`

`Comment fai’R pour détecter les valeurs manquantes dans une table ?`

`Comment fai’R un tri personnalisé dans une table ?`

`Comment fai'R pour importer des données depuis un fichier Excel contenant des en-têtes ?`

`Comment fai’R : les paramètres de mutate()`

Elles sont disponibles sur : *~/CERISE/01-Espace-de-Partage/SSP/BMIS/comment_fair*.


## Comment nommer les fichiers  ?

Les différents segments du nom d'un fichier sont séparés par un underscore (le caractère "_").

Les accents et les caractères spéciaux ne doivent pas être utilisés.

Idéalement, le nom du fichier ne sera pas trop long et suffisamment descriptif.

## Aide sur une fonction

Pour obtenir de l’aide sur une fonction (installée, peut-être non chargée):
```{r, eval = FALSE}
??nom_fonction
```
Pour obtenir de l’aide sur une fonction (installée et chargée):
```{r, eval = FALSE}
?nom_fonction
help(nom_fonction)
```
Documentation simplifiée : vignettes

Les vignettes sont des documents qui aident à prendre en main un package en identifiant ses fonctions les plus importantes, et en montrant un ou plusieurs cas d’usage.

Pour lister les vignettes relatives à un package (par exemple dplyr):

```{r, eval = TRUE}
vignette(package="dplyr")
```

Pour visualiser une vignette donnée :

```{r, eval = FALSE}
vignette("rowwise", package="dplyr") # dans RStudio
RShowDoc("rowwise", package="dplyr") # dans le navigateur web
```

Les cheatsheets (ou antisèches) sont des documents visant à résumer de manière graphique la fonction et l’usage d’un package.
Les plus utiles sont listées ici:
https://posit.co/resources/cheatsheets/

## L'encodage

Utiliser l'encodage `UTF-8`. Le nombre minimal de bits est 8. En fait, il représente les premiers caractères (ceux de l’ASCII) sur un octet, les suivants sur 2 octets, 3 et jusqu’à 4 octets.

https://orion.agriculture/confluence/pages/viewpage.action?pageId=285442455

## Les types de valeurs dans R

Une valeur constitue l'unité de base des données pour R. Comme pour la plupart des logiciels, elles peuvent être de trois **types** :

- **Numérique** : entier, double
- **Caractère** : texte ou code
- **Logique** : booléens

*En anglais : numeric, character et logical *

Les formats de dates sont de type character.

Chaque variable est du type de son contenu (numeric, character, logical). 
Si les valeurs prises par la variables correspondent à un nombre fini de modalités, **la variable peut être du type "factor"**. 
Ses composantes sont toujours d'un des 3 types décrits ci-dessus mais il est possible d'employer des fonctions spécifiques au traitement de modalités.
À chaque type de variable correspond une utilisation. 
Lors de l’import des données, un type est affecté automatiquement par R.
Mais le type peut être erroné. 
Il suffit alors de les convertir :

```{r converttype, eval = FALSE}
base <- mutate(base0, LIBGEO = as.character(LIBGEO))
```

ou `as.factor()`, `as.numeric()`, etc...

On peut aussi gérer les types au moment de l'importation (par exemple avec le paramètre `colClasses`).

### Travail sur les dates

```{r , eval = FALSE}
itavi <- itavi %>%
  mutate(an_mois_date = convertToDate(an_mois))
# itavi <- itavi %>% mutate(an_mois = substr(as.character(an_mois_date),1,7) ) 
# itavi <- itavi %>% gsub("-","_",itavi$an_mois)
# itavi <- itavi %>% str_replace_all("-","_")
itavi <- itavi %>% 
  mutate(annee = year(an_mois_date),
         mois = month(an_mois_date),
         an_mois =paste0(annee,"_",mois) ) 
```

## Les vecteurs

Les valeurs peuvent être structurées au sein de vecteurs. 
Ces vecteurs peuvent être vus comme des colonnes de valeurs toutes du même type.


**Vecteurs** : suite unidimensionnelle de **valeurs** ayant le même type.

Différentes fonctions permettent de créer des vecteurs.

```{r premierJeuDonnees}
vect_num <- c(1, 160, 2, 9)
vect_txt <- c("Je", "programme", "en", "R")
sequence <- seq(from = 1, to = 10, by = 1)
sequence_pareille <- 1:10
repetition <- rep("bla", 3)
```

**Facteurs** : vecteur qui prend un nombre limité de modalités (exemple : sexe). Il est défini par les niveaux (`levels`) et les libellés associés (`labels`).  On parle aussi de variables qualitatives ou catégorielles (de type catégoriel).


### Extraire un vecteur : `pull()`

`pull()` permet d'extraire sous forme de vecteur une variable d'un *dataframe.*

```{r, eval = FALSE}
stations_de_la_table_prelevement <- pull(prelevement, code_station)
stations_de_la_table_prelevement <- unique(stations_de_la_table_prelevement)
```

## Les dataframes

Plusieurs vecteurs de types différents possédant un même nombre de lignes peuvent être accolés pour former une **dataframe**.
Les dataframes sont les objets les plus courants dans le traitement de données usuel.
Il s'agit de tableaux dont les lignes correspondent à des observations et les colonnes à des variables.

Ces dataframes peuvent être créées par association des vecteurs avec les fonctions :
```{r, eval = FALSE}
dataframe_a <- data.frame(vect_num, vect_txt)
dataframe_b <- bind_cols("vect_num" = vect_num, "vect_txt" = vect_txt)
```

Une dataframe peut aussi être créée par l'import d'un tableau.


Il est possible d'accéder aux éléments d’une dataframe à partir du numéro de ligne et de colonne, grâce aux crochets :

<center>![](images/DF2.png)</center>

- `base[1,3]` $\rightarrow$ <span style="color:red">valeur de la première ligne et de la troisième colonne </span>
- `base[2,]` $\rightarrow$ <span style="color:blue">toutes les variables pour la 2e observation</span>
- `base[,4]` $\rightarrow$ <span style="color:green">toutes les observations de la quatrième colonne  </span>
- `base[,’V6’]` $\rightarrow$ <span style="color:cyan">toutes les observations de la variable V6</span>

Le *dataframe* est constitué de 
- n lignes (observations)
- p colonnes (variables)

<center>![](images/DF1.png)</center>


**Tableaux** (`data.frame`) : Objet qui ressemble le plus aux tables Excel, SAS ou SPSS... : description d'individus statistiques (observations, en ligne) par des caractéristiques (variables, en colonnes).

## Le `tibble` : un `data.frame` amélioré

**Le `tibble` est une version améliorée du `data.frame` de base.**  Il s'agit d'un `data.frame` standard, avec quelques propriétés supplémentaires qui rendent son utilisation plus facile. 

**Pour convertir un `data.frame` en `tibble` on utilise la fonction `tibble::as_tibble()`.** Dans l'exemple suivant, on charge la table de la base permanente des équipements puis on la convertit en `tibble`.

```{r, eval = FALSE}
# Charger la base permanente des équipements
bpe_ens_2018 <- doremifasolData::bpe_ens_2018
# Convertir ce data.frame en tibble
bpe_ens_2018_tbl <- as_tibble(bpe_ens_2018)
```
* **L'affichage des `tibbles` est meilleur que celui des `data.frames`.** Même sans la fonction `head()`, l'affichage d'un `tibble` affiche les dimensions de celui-ci (nombres de lignes et de colonnes), ainsi que le type des variables (en-dessous des noms des colonnes).
  
https://www.book.utilitr.org/03_fiches_thematiques/fiche_tidyverse#le-tibble-un-data.frame-am%C3%A9lior%C3%A9

## Les fonctions et les valeurs particulières
- NA : valeur manquante (*Not Available*) dans une dataframe ou en résultat d'une fonction
- NaN : pas un nombre (*Not a Number*) lorsqu'une fonction tente de diviser par 0
- -Inf, Inf : inﬁni positif ou négatif lorsque une fonction diverge

Une valeur manquante peut perturber l’exécution d'une fonction :
```{r}
V1 <- c(1, 14, NA, 32.7)
mean(V1)              # renvoie NA
mean(V1, na.rm = TRUE)   # renvoie 15.9
```
La fonction `coalesce(x, y)` permet de remplacer les valeurs manquantes de x par la valeur de y.


## Travailler avec les valeurs manquantes

```{r , eval = FALSE}
# mettre NA pour variable d'évolution avec regroupement
otex_regroupe <- otex_regroupe %>% 
  mutate(evol_2020_2019 = case_when(
    otex_code_regr %in% c("otex_5374_5100","otex_4813_4840") ~ as.numeric(NA), 
    TRUE   ~ evol_2020_2019),
    evol_2020_2010_par_an = case_when(
      otex_code_regr %in% c("otex_5374_5100","otex_4813_4840") ~ as.numeric(NA), 
      TRUE   ~ evol_2020_2010_par_an )
    )
# calcul evolution
otex_regroupe <- otex_regroupe %>%
  mutate(tx_evol_2020_2010_par_an = arrondi((((an_2020/an_2010)**(1/10)-1)*100),3),
         tx_evol_2020_2019 = arrondi(((an_2020/an_2019 -1)*100),3),
         otex_code = substr(otex_code_regr,6,10) ) %>%
  arrange(otex_code_regr) %>%
  left_join(otex %>% 
              select(otex_code,otex_lib),
            by = "otex_code") 

# remplacement valeurs NA pour regroupements
otex_regroupe <- otex_regroupe %>% 
  mutate(evol_2020_2010_par_an = case_when(
    is.na(evol_2020_2010_par_an) ~ arrondi(tx_evol_2020_2010_par_an,1),
    TRUE   ~ evol_2020_2010_par_an),
    evol_2020_2019 = case_when(
      is.na(evol_2020_2019) ~ arrondi(tx_evol_2020_2019,1),
      TRUE   ~ evol_2020_2019) )

# remplacement valeurs NA
unique(vab_agri_2020_2$libreg)
vab_agri_2020_3 <- vab_agri_2020_2 %>% 
  filter(libreg != "France métropolitaine hors Ile-de-France") %>% 
  mutate(reg = case_when(
      is.na(reg) ~ "FM",
    TRUE ~ reg))

# transformation des valeurs numériques manquantes par des zéros 
exploit_prod_anim_pdl <- exploit_prod_anim_pdl %>% 
  mutate(across(where(is.numeric), ~ replace(., is.na(.), 0)))
```

### `replace_na` : remplacer des valeurs manquantes

La fonction `replace_na` permet de remplacer des valeurs manquantes (`NA`). Cette fonction peut être utilisée de deux façons, que l'on va illustrer avec les données suivantes :

```{r replace_na}
df <- tibble::tibble(x = c(1, 2, 3, NA), y = c("a", NA, "b", NA))
df
```

Premier usage : on remplace les valeurs manquantes **dans une colonne** d'un `data.frame`. Dans ce cas, la fonction prend deux arguments : le nom de la variable et la valeur utilisée pour remplacer les valeurs manquantes. Voici un exemple :

```{r replace_na2}
library(magrittr) # pour utilisation %>%
library(tidyr) # pour replace_na
df %>% 
  dplyr::mutate(x = replace_na(x, 888))
```

Second usage : on remplace les valeurs manquantes **dans toutes les colonnes** d'un `data.frame`. Dans ce cas, la fonction prend deux arguments : le nom du `data.frame`, et une liste donnant pour chaque variable la valeur à utiliser pour remplacer les valeurs manquantes. Voici un exemple :

```{r replace_na3}
df %>% 
  replace_na(list(x = 888, y = "zzz"))
```

replace_na()
```{r, eval = FALSE}
# Créer une nomenclature agrégée libelle_ab_regroupt à partir de libelleonab et libelle_ab_2
# La valeur de libelle_ab_regroupt est basée sur libelle_ab_2 
# si libelle_ab_2 correspond à "Pommes" et sur libelleonab sinon

# pb avec == si présence de valeurs manquantes
bio_pdl_nomenclature_pb_na <- bio_pdl_nomenclature %>% 
  mutate(libelle_ab_regroupt = ifelse(libelle_ab_2=="Pommes", yes=libelle_ab_2, no=libelleonab))
unique(bio_pdl_nomenclature_pb_na$libelle_ab_regroupt)

# %in% permet de gérer la présence de valeurs manquantes
bio_pdl_nomenclature <- bio_pdl_nomenclature %>% 
  mutate(libelle_ab_regroupt = ifelse(libelle_ab_2 %in% c("Pommes"), 
                                      yes=libelle_ab_2, 
                                      no=libelleonab))
unique(bio_pdl_nomenclature$libelle_ab_regroupt)

# on remplace au préalable les valeurs manquantes si on souhaite utiliser ==
bio_pdl_nomenclature_renommage_na <- bio_pdl_nomenclature %>% 
  mutate(libelle_ab_2 = replace_na(libelle_ab_2, "hors_pommes"))

# Créer une nomenclature agrégée libelle_ab_regroupt à partir de libelleonab et libelle_ab_2
# La valeur de libelle_ab_regroupt est basée sur libelle_ab_2 
# si libelle_ab_2=="Pommes" et sur libelleonab sinon
bio_pdl_nomenclature_gestion_na <- bio_pdl_nomenclature_renommage_na %>% 
  mutate(libelle_ab_regroupt = ifelse(libelle_ab_2=="Pommes", 
                                      yes=libelle_ab_2, 
                                      no=libelleonab))
unique(bio_pdl_nomenclature$libelle_ab_regroupt)

```

## Les principes des fonctions de `dplyr`

Le but du package `dplyr}` est d'identifier et de rassembler dans un seul package les outils de manipulation de données. Ce package rassemble donc des fonctions correspondant à un ensemble d'opérations élémentaires (ou *verbes*) qui permettent de : 

- Sélectionner un ensemble de variables : `select()`  
- Sélectionner un ensemble de lignes : `filter()`  
- Ajouter/modifier/renommer des variables : `mutate()` ou `rename()`  
- Produire des statistiques agrégées sur les dimensions d'une table : `summarise()`  
- Trier une table : `arrange()`  
- Manipuler plusieurs tables : `left_join()`, `right_join()`, `full_join()`, `inner_join()`...  

D'appliquer cela en articulation avec `group_by()` qui change la façon d'interpréter chaque fonction : d'une interprétation *globale* sur l'ensemble d'une table, on passe alors à une approche *groupe par groupe* : chaque groupe étant défini par un ensemble des modalités des variables définies dans l'instruction `group_by()`.


## Qu'est-ce que l'opérateur `pipe` ?

Lorsqu'on enchaîne les manipulations sur une table de données, un problème est que le code devient peu lisible car il y a beaucoup d'opérations imbriquées les unes dans les autres, avec un grand nombre de parenthèses ou de crochets. **L'opérateur `pipe` (noté `%>%`) du package `magrittr` permet de résoudre ce problème en réécrivant les opérations de façon plus lisible.** Le principe de l'opérateur `pipe` est très simple :

* le terme qui précède l'opérateur est utilisé comme **premier** argument de la fonction qui suit l'opérateur ;
* les opérations peuvent être enchaînées en enchaînant les opérateurs `pipe` ;
* l'opérateur `pipe` fonctionne quelle que soit la nature de l'argument ;
* l'opérateur `pipe` fonctionne également à l'intérieur de parenthèses.

Voici un petit tableau qui vous donne des exemples : 

| **Ce code est équivalent à...**      | **... ce code**                                     |
|--------------------------------------|-----------------------------------------------------|
| `fonction(x)`                        | `x %>% fonction()`                                  |
| `fonction3(fonction2(fonction1(x)))` | `x %>% fonction1() %>% fonction2() %>% fonction3()` |
| `mutate(tibble, y = log(x))`        | `tibble %>% mutate(y = x %>% log())`               |

Avec l'usage du pipe, le premier argument -qui devrait être une table- disparaît de l'appel aux fonctions 'dplyr' (filter, arrange...) En effet, le pipe envoie le résultat de la ligne précédente comme premier argument de la ligne suivante.

### Comment utiliser l'opérateur `pipe` avec le `tidyverse`

**Un traitement statistique avec les _packages_ du `tidyverse` prend généralement la forme d'une succession de verbes séparés par l'opérateur `pipe` (`%>%`).** Il est possible d'aller à la ligne en mettant le `pipe` en bout de ligne (mais pas en début de ligne).

Voici un exemple détaillé pour comprendre l'utilisation du `pipe`. Ce code se lit comme ceci : on part de la base permanente des équipements 2018, puis on la transforme en `tibble`, puis on conserve uniquement les stations services `TYPEQU == "B316"`, puis on groupe les observations par département `group_by(DEP)`, puis on calcule la somme du nombre de stations-services par département `summarise(nb_equip_total = sum(NB_EQUIP, na.rm = TRUE))`.

```{r, eval = FALSE}
nombre <- bpe_ens_2018 %>%
  as_tibble() %>%
  filter(TYPEQU == "B316") %>% 
  group_by(DEP) %>% 
  summarise(nombre_station_serv = sum(NB_EQUIP, na.rm = TRUE)) 

# on ne conserve que les exploitations avec des bovins
exploit_bovins_a <- exploit_anim_sel %>%  
  filter(bovinfil == 1)

# Calculer par département, le nombre d’exploitations ayant des vaches, avec l’effectif de vaches
nb_exploit_vaches_pdl <- exploit_bovins_c %>%
  filter(cheptq_111000>0) %>% 
  group_by(siege_dep) %>% 
  summarise(nb_expl=n(),
            vaches=sum(cheptq_111000)) %>% 
  ungroup() %>% 
  adorn_totals(where = c("row"), name="Pays de la Loire" )

# Calculer par département, le nombre d’exploitations ayant des vaches, avec l’effectif de vaches
# La fonction summarise() permet d’agréger des données, en appliquant une fonction sur les variables 
# pour construire une statistique sur les observations de la table.
# C’est une fonction dite de “résumé”.
nb_exploit_vaches_dep <- exploit_bovins_c %>%
  filter(cheptq_111000>0) %>% 
  group_by(siege_dep) %>% 
  summarise(nb_expl=n(),
            vaches=sum(cheptq_111000)) %>% 
  ungroup()
  
# ajouter la part par rapport à l'ensemble de la région
nb_exploit_vaches_dep_reg <- nb_exploit_vaches_dep %>%
  mutate(nb_expl_reg=sum(nb_expl),
         vaches_reg=sum(vaches),
         part_expl = nb_expl / nb_expl_reg * 100,
         part_vaches = vaches / vaches_reg * 100) %>% 
  adorn_totals(where = c("row"), name="Pays de la Loire" ) %>% 
  mutate(across(c(part_expl,part_vaches), ~ arrondi(.,digits=3)))

```
https://www.book.utilitr.org/03_fiches_thematiques/fiche_tidyverse#encha%C3%AEner-les-manipulations-avec-lop%C3%A9rateur-pipe

### Exemple d'utilisation du pipe `%>%`
On peut combiner les opérations à l'aide de l'opérateur pipe `%>%` :

```{r, eval = FALSE}
selection_62 <- base %>%
  mutate(densite = P14_POP / SUPERF,
         tx_natal = 1000 * NAISD15 / P14_POP,
         tx_mort = 1000 * DECESD15 / P14_POP) %>%
  select(CODGEO, ZAU, REG, DEP, densite, tx_natal) %>%
  filter(DEP == "62")
```
Cette écriture permet d'enchaîner les opérations telles qu'on les décrirait à l'oral.
L'objet auquel s'applique chaque nouvelle opération est le résultat de l'opération précédente.

Sans le pipe `%>%`, pour enchaîner des opérations, on peut créer des variables successives :
```{r,  eval = FALSE}
df <- mutate(base, densite = P14_POP / SUPERF,
             tx_natal = 1000 * NAISD15 / P14_POP,
             tx_mort = 1000 * DECESD15 / P14_POP)
selection <- select(df, CODGEO, ZAU, REG, DEP, densite, tx_natal)
filtre_62 <- filter(selection, DEP == "62")
```

Sans le pipe `%>%`, on peut emboîter les fonctions avec des () :
```{r,  eval = FALSE}
selection_62 <- filter(select(mutate(base, densite = P14_POP / SUPERF,
                                     tx_natal = 1000 * NAISD15 / P14_POP,
                                     tx_mort = 1000 * DECESD15 / P14_POP),
                              CODGEO, ZAU, REG, DEP, densite, tx_natal), 
                       DEP == "62")
```
La lecture est particulièrement confuse et le risque d'oubli de parenthèses important.

## Les tests logiques dans R

Syntaxe             | Action
--------------------|----------------------------------------
`==`                |  Test d'égalité
`!=`                |  Différent de
`%in%  c(...)`      |  Dans une liste de valeurs 
`>, >= ,  <, <=`    |  Supérieur (ou inférieur) (ou égal)
`! (x %in% c(...))` |  N'est pas dans une liste de valeurs 

```{r, eval=FALSE}
table_sortie <- filter(table_entree, x==a & y==b) # x vaut a **ET** y vaut b
table_sortie <- filter(table_entree, x==a | y==b) # x vaut a **OU** y vaut b (barre verticale AltGR+6)
```

## Ajout d'une fonction `not_in`
```{r fonction not_in, eval = TRUE}
# Création d'une fonction `%not_in%`
`%not_in%` <- purrr::negate(`%in%`)
```
à placer en début de programme


## La question des arrondis

La fonction 'round' arrondit selon le principe de la parité.
Pour arrondir systématiquement à l'excès (en valeur absolue) au-delà de 5, il convient d'utiliser une fonction spécifique (à placer en début de programme), comme la fonction round_half_up() du package `janitor`.

La fonction 'round' standard de R applique la norme IEC 60559 qui indique que pour l'arrondi de 5 on arrondit au chiffre pair le plus proche (ce qui évite de surestimer systématiquement les valeurs en arrondissant toujours au dessus).

https://fr.wikipedia.org/wiki/Arrondi_(math%C3%A9matiques)


```{r fonctions arrondi, eval = TRUE}
# floor : l'entier le plus proche inférieur ou égal à l'argument (partie entière) 
# ceiling : l'entier le plus proche supérieur ou égal à l'argument
# trunc : équivalent de floor pour les valeurs positives et de ceiling pour les valeurs négatives

# Fonction pour gérer les arrondis de .5 (renommage de la fonction janitor::round_half_up)
arrondi <- function(x, digits = 0) {
  posneg <- sign(x)
  z <- abs(x) * 10^digits
  z <- z + 0.5 + sqrt(.Machine$double.eps)
  z <- trunc(z)
  z <- z / 10^digits
  z * posneg
}

# Avec 'arrondi', si le nombre se situe à mi-chemin, 
# il est arrondi à la valeur la plus proche au-dessus (pour les nombres positifs)
# ou en dessous (pour les nombres négatifs).

# Comparaison des fonctions 'round' et 'arrondi'
# L'aide de la fonction 'round' indique que les arrondis respectent la norme IEC 60559 
# qui prévoit que l'arrondi soit à la valeur de décimale paire la plus proche 
# donc round (3.5,digits=0) donne 4 tout comme round(4.5,digits=0). 

# données exemple
v1 <- seq(from = 0.5, to =9.5, by=1)
v1
# [1] 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5

# fonction 'round' de Base R
r1 <- round(v1)
# arrondi au chiffre pair le plus proche
r1
# [1]  0  2  2  4  4  6  6  8  8 10

# fonction 'arrondi' vers le plus loin de zéro 
a1 <- arrondi(v1)
# arrondi au supérieur (vers le haut en valeur absolue) 
a1
# [1]  1  2  3  4  5  6  7  8  9 10

# avec des valeurs négatives
v1neg <- -v1
v1neg
# [1] -0.5 -1.5 -2.5 -3.5 -4.5 -5.5 -6.5 -7.5 -8.5 -9.5

# avec 'round'
r_neg <- round(v1neg)
r_neg
# [1]   0  -2  -2  -4  -4  -6  -6  -8  -8 -10

# fonction 'arrondi'
a_neg <- arrondi(v1neg)
# 'arrondi' pour valeurs négatives
a_neg
# [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10

# autre exemple
v2 <- seq(-2, 2, by=0.5)
v2
# [1] -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0
r2 <- round(v2)
r2
# [1] -2 -2 -1  0  0  0  1  2  2
a2 <- arrondi(v2)
a2
# [1] -2 -2 -1 -1  0  1  1  2  2

# exemple
# Les noms des colonnes peuvent être appelés avec la syntaxe `nomtable$nomvariable`. 
# L’indexation des colonnes de tables (le “$”) permet d'appeler une variable.

# volailles_pdl_sum$tec_regrpt <- arrondi(volailles_pdl_sum$tec_regrpt,digits=2)

# eff_volailles_evol <- eff_volailles_annee %>% 
#   mutate(evol_2021_2020 = paste0(arrondi((((an_2021/an_2020)-1)*100),0)," %"),
#          reg = case_when(
#            region %in% c("52  -  Pays de la Loire") ~ "pdl",
#            region %in% c("98  -  Total France métropolitaine") ~ "fm") )


```
Application de la fonction `arrondi` à plusieurs variables, en utilisant la fonction `across`

```{r, eval=FALSE}
# ajout de la comparaison au niveau reg et au niveau FM (en %)
names(recolte_bois_dep_reg)
recolte_bois_dep_reg <- recolte_bois_dep_reg %>%
  mutate(valeur_dep_percent_reg = valeur_dep/valeur_reg*100,
         valeur_dep_percent_fm = valeur_dep/valeur_fm*100,
         valeur_reg_percent_fm = valeur_reg/valeur_fm*100,
         .after=dep) %>% 
  mutate(across(contains("percent"), ~ arrondi(.,digits=2)))

```

## Gestion du secret

```{r , eval = FALSE}
# gestion secret
# messages non contraignants Warning messages:
# 1: Problem while computing as.numeric(producteurs_2020) 
# i NAs introduits lors de la conversion automatique 
lait_vache_reg_dep_2021_donnees_secret_1 <- lait_vache_reg_dep_2021_donnees %>% 
  mutate(livraisons_2021=as.character(livraisons_2021) ) %>% 
  mutate(livraisons_2021=ifelse(as.numeric(producteurs_2021) > 0 & 
                                as.numeric(producteurs_2021) < 3,"Secret",livraisons_2021) ) %>%
  mutate(producteurs_2021=ifelse(as.numeric(producteurs_2021) > 0 & 
                                as.numeric(producteurs_2021) < 3,"Secret",producteurs_2021) ) %>% 
  mutate(livraisons_2021=ifelse(Département=="Hérault","Secret",livraisons_2021) ) %>%
  mutate(producteurs_2021=ifelse(Département=="Hérault","Secret",producteurs_2021) )
  
# gestion secret
# au moins 3 établissements 
exploit_volailles_com_secret_1 <- exploit_volailles_com %>% 
  mutate(secret_eff_01_canards_com=ifelse(nb_exploit_01_canards_com > 0 & 
                                          nb_exploit_01_canards_com < 3,"Secret",eff_01_canards_com),   
  secret_nb_exploit_01_canards_com=ifelse(nb_exploit_01_canards_com > 0 & 
                                          nb_exploit_01_canards_com < 3, 
                                          "Secret",
                                          nb_exploit_01_canards_com),
  secret_eff_02_dindes_com=ifelse(nb_exploit_02_dindes_com > 0 & 
                                  nb_exploit_02_dindes_com < 3,"Secret",eff_02_dindes_com),         
  secret_nb_exploit_02_dindes_com=ifelse(nb_exploit_02_dindes_com > 0 & 
                                         nb_exploit_02_dindes_com < 3,"Secret",nb_exploit_02_dindes_com))
# 1 établissement < 85 % total
# recherche plus gros établissement
# gros_exploit_volailles <- exploit_volailles_com %>% 
#   group_by(depcom_2022) %>% 
#   slice(which.max(eff_01_canards))
# division par zéro crée NaN, qu'on va remplacer par 0
exploit_volailles_com_secret_2 <- exploit_volailles_com_secret_1 %>%
  group_by(depcom_2022) %>% 
  mutate(max_eff_01_canards_com=max(eff_01_canards),
         max_eff_02_dindes_com=max(eff_02_dindes)) %>% 
  mutate(part_max_eff_01_canards_com=max_eff_01_canards_com/eff_01_canards_com*100 %>% arrondi(digits=2),
         part_max_eff_02_dindes_com=max_eff_02_dindes_com/eff_02_dindes_com*100 %>%
           arrondi(digits=2)) %>%  
  mutate(across(everything(), ~ replace(., is.nan(.), 0)))
  
exploit_volailles_com_secret_3 <- exploit_volailles_com_secret_2 %>% 
  mutate(secret_eff_01_canards_com=ifelse(part_max_eff_01_canards_com >= 85,
                                          "Secret",
                                          secret_eff_01_canards_com),         
         secret_nb_exploit_01_canards_com=ifelse(part_max_eff_01_canards_com >= 85,
                                                 "Secret",
                                                 secret_nb_exploit_01_canards_com),
         secret_eff_02_dindes_com=ifelse(part_max_eff_02_dindes_com >= 85,
                                         "Secret",
                                         secret_eff_02_dindes_com),         
         secret_nb_exploit_02_dindes_com=ifelse(part_max_eff_02_dindes_com >= 85,
                                                "Secret",
                                                secret_nb_exploit_02_dindes_com))

```

## Calculer des statistiques spécifiques

Les fonctions `sum()`, `mean()`, `median()`, `min()`, `max()`, `var()`, `sd()`... résument l'information pour en donner une statistique.
La fonction `quantile()` renvoie les quartiles de la variables (ou bien tout autre découpage qu'on lui renseigne).

```{r,  eval = FALSE}
sum(pull(base_extrait, P14_POP), na.rm = TRUE)
mean(pull(base_extrait, P14_POP), na.rm = TRUE)
median(pull(base_extrait, P14_POP), na.rm = TRUE)
quantile(pull(base_extrait, P14_POP), probs = c(0.25, 0.5, 0.75), na.rm = TRUE)

# recherche de seuils
quantile(pull(exploit_anim_produit_grand_pdl, chair_tot), 
         probs = c(0, seq(from = 0.10, to = 1.0, by = 0.10)), 
         na.rm = TRUE)
quantile(pull(exploit_anim_produit_grand_pdl, chair_tot), 
         probs = c(0, seq(from = 0.05, to = 1.0, by = 0.05)), 
         na.rm = TRUE)
quantile(pull(exploit_anim_produit_grand_pdl, chair_tot), 
         probs = c(seq(from = 0.95, to = 1.0, by = 0.01)), 
         na.rm = TRUE)
```

Ces fonctions retournent une valeur, ou bien un ensemble de valeur (pour `quantile()`). Le résultat est donc un vecteur de un ou plusieurs nombres.

On utilise le paramètre `na.rm = TRUE` pour gérer les valeurs manquantes.

## Comment ajouter le total régional à des données par département ?

La première méthode consiste à utiliser la fonction 'adorn_totals' du package `janitor`. 

```{r,  eval = FALSE}
# nb exploitations par département et pour la région
# méthode 1 avec adorn_totals
nb_exploit_2020_dep_reg <- exploit_2020 %>% 
  select(nom_dossier,siege_dep) %>% 
  group_by(territoire = siege_dep) %>% 
  summarise(nb_total_exploitations = n() ) %>% 
  ungroup() %>% 
  adorn_totals(where = c("row"), name="Pays de la Loire" )

# ajouter le total régional (sauf pour les variables avec %)
bio_pdl_dep <- bio_pdl_dep %>%
  select(-c(contains("_pct"))) %>% 
  adorn_totals(where = c("row"), name="Pays de la Loire")

```

La deuxième méthode consiste à réaliser les sommes (ou moyennes) pour le niveau régional, et à concaténer ensuite les lignes avec le niveau départemental. 

```{r,  eval = FALSE}
# méthode 2 avec ajout variable territoire commune (pour département et région)
# nb exploitations par département
nb_exploit_2020_dep <- exploit_2020 %>% 
  select(nom_dossier,siege_dep,sau_tot) %>% 
  group_by(territoire = siege_dep) %>% 
  summarise(nb_total_exploitations = n(),
            SAU_moyenne_ha = sum(sau_tot, na.rm = TRUE) / n() ) %>% 
  ungroup()      

# méthode 2.1 nb exploitations pour la région
nb_exploit_2020_reg_a <- exploit_2020 %>% 
  select(nom_dossier,siege_dep,sau_tot) %>% 
  summarise(nb_total_exploitations = n(),
         SAU_moyenne_ha = sum(sau_tot, na.rm = TRUE) / n() ) %>% 
  mutate(territoire = "Pays de la Loire") 
# méthode 2.2 nb exploitations pour la région
nb_exploit_2020_reg_b <- exploit_2020 %>% 
  select(nom_dossier,siege_dep,sau_tot) %>% 
  mutate(territoire = "Pays de la Loire",
         nb_total_exploitations = n(),
         SAU_moyenne_ha = sum(sau_tot, na.rm = TRUE) / n() ) %>% 
  distinct(territoire,nb_total_exploitations,SAU_moyenne_ha)

# nb exploitations par département et pour la région par concaténation des lignes
nb_exploit_2020_dep_reg2a <- bind_rows(nb_exploit_2020_dep,nb_exploit_2020_reg_a)
nb_exploit_2020_dep_reg2b <- bind_rows(nb_exploit_2020_dep,nb_exploit_2020_reg_b)
```
## Calcul de rangs

```{r,  eval = FALSE}
# Calcul de rangs 1 ----  
# ajout des rangs au niveau dep, par categorie
# créer les variables valeur_dep_rang à partir de valeur_dep
# et valeur_dep_rang1_a correspondant à libdep
# pour valeur_dep_rang correspondant au 1er rang
# arrondi à l'entier le plus petit avec floor 
# floor Retourne la valeur du plus grand entier inférieur ou égal au nombre spécifié.
# partie entière : nombre entier immédiatement inférieur ou égal au nombre spécifié. 
recolte_bois_dep_reg <- recolte_bois_dep_reg %>%
  group_by(categorie) %>%
  mutate(valeur_dep_rang = rank(-valeur_dep),
         .before=1) %>%
  mutate(valeur_dep_rang1_a=ifelse(valeur_dep_rang==1,yes=libdep,no=""),
         .after=valeur_dep_rang) %>% 
  mutate(across(ends_with("rang"),floor)) %>% 
  ungroup()

# Calcul de rangs 2 ----  
# ajout du rang 1 (département) à l'ensemble des lignes
# on réalise une jointure de la table avec elle-même 
# pour affecter la valeur d’une variable à une autre variable. 
# Dans l’exemple suivant, on affecte la valeur (le 1er dep)
# de valeur_dep_rang1 relative à valeur_dep_rang==1.
# on prend valeur_dep_rang1 correspondant au dep du rang1 
# (pour valeur_dep_rang == 1) et on affecte la valeur 
# pour l'ensemble des cas 
# jointure de l'ensemble des lignes avec la ligne contenant valeur_dep_rang1 (le 1er dep)
# ligne par ligne
recolte_bois_dep_reg <-  recolte_bois_dep_reg %>% 
  mutate(commun = 1) 

# en 2 étapes
recolte_bois_dep_reg_rang1_etape1 <-  recolte_bois_dep_reg %>%
  select(categorie,commun,
         valeur_dep_rang_y=valeur_dep_rang,
         valeur_dep_rang1=valeur_dep_rang1_a) %>%
  filter(valeur_dep_rang_y == 1)

recolte_bois_dep_reg_2_etape2 <-  recolte_bois_dep_reg %>%
  left_join(recolte_bois_dep_reg_rang1_etape1,
            by=c("categorie","commun")) %>% 
  select(-c(valeur_dep_rang1_a,valeur_dep_rang_y))

# en une étape
recolte_bois_dep_reg_2 <-  recolte_bois_dep_reg %>%
  left_join(recolte_bois_dep_reg %>% 
              select(categorie,commun,
                     valeur_dep_rang_y=valeur_dep_rang,
                     valeur_dep_rang1=valeur_dep_rang1_a) %>%
              filter(valeur_dep_rang_y == 1),
            by=c("categorie","commun")) %>% 
  select(-c(valeur_dep_rang1_a,valeur_dep_rang_y))
  
```


## Erreurs fréquentes

R est prêt à exécuter une commande lorsque le chevron > est affiché dans la console. Si le chevron n'apparaît pas, c'est qu'une commande est incomplète. Appuyer sur 'Echap' ('ESC') pour sortir de cette commande.


### `Error in nom_de_la_fonction()`
impossible de trouver la fonction "nom_de_la_fonction"

Cela signifie que le package auquel appartient la fonction n'est pas chargé, voire pas installé.
Il convient alors d'ajouter :
```{r,  eval = FALSE}
library(nom_package)
```

### `there is no package called ‘nom_package’`

```{r,  eval = FALSE}
library(nom_package)
```
Il convient alors d'ajouter dans le fichier 'installation_packages.R'
```{r,  eval = FALSE}
install.packages("nom_package")
```

### erreur avec `mutate` associé à `case_when`
```{r, eval=FALSE}
> rp_individu_pdl_age_actif <-  rp_individu_pdl_var %>% 
+   mutate(age=case_when(agerevq %in% c("20","25","30","35","40","45","50","55","60") ~ "a_20_64_ans",
+                        TRUE ~ agerevq),
+          actif=case_when(tact %in% c(11,12) ~ "actifs",
+                          TRUE ~ tact) )
```
```{r, eval=FALSE}
Error in `mutate()`:
! Problem while computing `actif = case_when(tact %in% c(11, 12) ~ "actifs", TRUE ~ tact)`.
Caused by error in `` names(message) <- `*vtmp*` ``:
! attribut 'names' [1] doit être de même longueur que le vecteur [0]
Run `rlang::last_error()` to see where the error occurred.
```
En effet, la valeur associée à TRUE ~ doit être de même type que la variable créée (ici actif), soit de type caractère.
En associant, TRUE ~ à un élément de type "caractère", cela a résolu le problème.

```{r, eval=FALSE}
> rp_individu_pdl_age_actif <-  rp_individu_pdl_var %>% 
+   mutate(age=case_when(agerevq %in%
                           c("020","025","030","035","040","045","050","055","060") ~ "a_20_64_ans",
+                        TRUE ~ agerevq),
+          activite=case_when(tact %in% c(11,12) ~ "actifs",
+                          TRUE ~ "inactifs") )
> 
```

***

<br>

## Tableau de contingence

La fonction `table()` calcule les effectifs d'un tableau croisé :
```{r, eval = FALSE}
t <- base_extrait %>% 
  select(ZAU, REG) %>% 
  table()
print(t)
```

## Tableau de proportions

La fonction `prop.table()` prend en entrée un objet `table` (tableau de contingence avec les effectifs) et calcule les pourcentages (total, ligne, colonne) associés $\rightarrow$ `?prop.table`

```{r, eval = FALSE}
# Calcule la fréquence en % (la somme de tous les pourcentages vaut 100)
(prop.table(t) * 100) %>% 
  round(digits = 1)
```

```{r, eval = FALSE}
# Calcule la fréquence en % par région (la somme de tous les pourcentages d'une colonne vaut 100)
(prop.table(t,"REG") * 100) %>% 
  round(digits = 1)
```

## Extraire une chaîne de caractères avec `str_sub()`  

Le package `stringr` propose des fonctions de manipulation de chaînes de caractère.

Extraire une chaîne de caractères avec `str_sub()`  

`str_sub()` prend 3 arguments : une chaîne de caractère, une position de début, une position de fin.
Les positions peuvent être positives, et dans ce cas, on compte à partir de la gauche, ou négatives, et dans ce cas on compte à partir de la droite.

```{r}
library(dplyr)
library(stringr)
a <- data.frame(x = c(" libeatg", "delivo y"))
b <- mutate(a, pos3a4 = str_sub(string = x, start = 3, end = 4),
               pos3a2avtlafin = str_sub(string = x, start = 3, end = -2))
```

`str_sub()` peut être utilisé pour remplacer un caractère

```{r}
str_sub(a$x, start = 6, end = 9) <-"rer"
a$x
```

Si on souhaite réaliser ce genre d'opération dans le cadre d'un `mutate`, il faut utiliser 
une fonction dite "pipe-operator-friendly", par exemple `stri_sub_replace()` du package `stringi`

```{r}
# install.packages("stringi")
library(stringi)
a <- data.frame(x = c(" libeatg", "delivo y"))
b <- mutate(a, y=stri_sub_replace(str=x, from=6, to=9, value = "rer"))
```

## Obtenir la longueur d'une chaîne de caractères avec `str_length()` :

```{r}
library(stringr)
str_length("abc")
```

## Remplacer partout les points par des virgules, en vue d'un export vers excel

```{r, eval = FALSE}
library(stringr) # pour str_replace
# remplacement point par virgule
lait_vache_reg_dep_2021_donnees_secret_2 <- lait_vache_reg_dep_2021_donnees_secret_1 %>% 
  mutate(across(
    .cols=everything(),
    ~ str_replace(., "[.]", ",")))
```

## Utiliser les expressions régulières

Les **expressions régulières** permettent la détection de "patterns" sur des chaînes de caractères. Par exemple "^" sert à indiquer que la chaîne de caractère recherchée doit se trouver au début de la chaîne examinée. Au contraire, "$" sert à indiquer que la chaîne de caractère recherchée doit se trouver à la fin.


```{r}
a <- data.frame(txt = c("vélo", "train", "voilier", "bus", "avion", "tram", "trottinette"))
b <- mutate(a, tr_au_debut = str_detect(string = txt, pattern = "^tr"))
b
filter(b, tr_au_debut)
filter(a, str_detect(string = txt, pattern = "n$"))
```

## Ecriture de fonctions

La fonction est un objet comme les autres, qu'on crée avec l'opérateur d'affectation. Elle est définie par des paramètres et elle se termine souvent par la fonction `return()`. 

```{r}
# Exemple du calcul de l'IMC
calcul_IMC <- function (poids, taille)
{
  ## La taille est exprimée en mètres
  imc <- poids / taille ^ 2
  return (imc)
}
calcul_IMC (poids = 80, taille = 1.89)
calcul_IMC (poids = 60, taille = 1.55)
```

```{r, eval = FALSE}
# fonction secteurs
secteur_1 <- function(df)  {
  df %>% 
    select(region,'2019','2020') %>% 
    filter(region %in% c("France métropolitaine","Pays de la Loire")) 
}
# nouvelle variable emploi_salarie en mettant la liste des especes par transposition
secteur_2 <- function(df)  {
  df %>%   
    pivot_longer(cols = c('2019','2020'), 
                 names_to = c("annee"),
                 values_to = "nb_emploi_salarie")
}

# utilisation fonction secteur
b_iaa <- secteur_1(b_iaa)
# ajout colonne secteur
b_iaa_long <- secteur_2(b_iaa)  %>% 
  mutate(secteur = "b2_iaa")

# fonction pour an_semestre en colonne
an_sem_col <- function(df)  {
   df %>% 
   pivot_wider( names_from = c(annee,semestre), names_prefix="an_",
                values_from = montant)
   }
# utilisation fonction pour an_semestre en colonne   
produits_AZ_C1_reg <- an_sem_col(produits_long_AZ_C1_reg)

# fonction pour calcul évolutions et / semestre précédent
calcul_evol <- function(df)  {
   df %>% 
      mutate(diff2022_sem1_evol = an_2022_sem1 - an_2021_sem1,
             diff2022_sem1_evol_perc = (an_2022_sem1/an_2021_sem1-1)*100,
             diff2021_sem2_evol_prec = an_2021_sem2-an_2021_sem1,
             diff2021_sem2_evol_prec_perc = ( an_2021_sem2/an_2021_sem1 -1)*100,
             diff2022_sem1_evol_prec = an_2022_sem1-an_2021_sem2,
             diff2022_sem1_evol_prec_perc = ( an_2022_sem1/an_2021_sem2 -1)*100 
             )
}
# utilisation fonction calcul évolutions
produits_AZ_C1_reg <- calcul_evol(produits_AZ_C1_reg) 

# fonction pour arrondi évolutions 
arrondi_evol <- function(df)  {
  df %>% 
  mutate(diff2022_sem1_evol_perc=arrondi(diff2022_sem1_evol_perc, digits=2),
  diff2021_sem2_evol_prec_perc=arrondi(diff2021_sem2_evol_prec_perc, digits=2),
  diff2022_sem1_evol_prec_perc=arrondi(diff2022_sem1_evol_prec_perc, digits=2) )
}
# utilisation fonction arrondi évolutions 
produits_AZ_C1_reg <- arrondi_evol(produits_AZ_C1_reg) 

```
```{r, eval = FALSE}
# cas de plusieurs modalités par variable
# traitement récurrent
# fonction pour effectuer la transformation des données dep + reg
transform_data <- function(data_entree) {
  data_dep_1 <- data_entree %>%
    select(-contains("reg")) %>% 
    pivot_longer(cols = contains("_dep"), 
                 names_to = "indicateur", 
                 values_to = "donnees_dep", 
                 names_pattern = "(.*)_dep")
  
  data_dep_2 <- data_dep_1 %>%
    pivot_wider(names_from = depart, 
                values_from = donnees_dep)
  
  data_reg <- data_entree %>% 
    select(-contains("dep")) %>% 
    pivot_longer(cols = contains("_reg"),
                 names_to = "indicateur",
                 values_to = "ensemble",
                 names_pattern = "(.*)_reg") %>% 
    distinct()
  
  # regroupement dep reg avec left_join 
  agreg_data_dep_reg <- data_dep_2 %>% 
    left_join(data_reg, 
              by = c("indicateur","modalites"))
  
  return(agreg_data_dep_reg)
}
# utilisation de la fonction transform_data
agreg_tr_surf_logt_vol_chair_grand_dep_reg_2 <- transform_data(data_entree=agreg_tr_surf_logt_vol_chair_grand)
```

## Les boucles conditionnelles

Les commandes `if` et `else` sont utilisables. Le "then" n'existe pas : il est implicite après les accolades.

```{r}
diag_IMC <- function(poids,taille)
{
  imc <- poids / taille ^ 2
  if (imc < 18.5) {diag <- "maigre"}
  else if (imc < 25) {diag <- "normal"}
       else {diag <- "surpoids"}
  return (diag)
}
diag_IMC (poids=60,taille=1.89)
diag_IMC (poids=80,taille=1.89)
diag_IMC (poids=80,taille=1.55)
```


## Les boucles

On peut utiliser les boucles classiques : `repeat`, `while`, `for` :

```{r}
for (pp in seq(from = 50, to = 100, by = 5))
{
  print(paste ("Taille = 1,70m, poids =", pp, "Diagnotic :",
               diag_IMC (poids = pp, taille = 1.70)))
}
```

On peut aussi appliquer des fonctions sur les lignes, colonnes et autres dimensions grâce à la fonction  ```apply()```.

## Exemples de nomenclatures

```{r, eval = FALSE}
# code a17
secteur_a17 <- data.frame(a_17 = c("AZ","DE","C1","C2","C3","C4","C5","FZ","GZ","HZ","IZ","JZ","KZ","LZ","MN","OQ","RU"),
                             a17_lib_detail = c("Agriculture, sylviculture et p\u00eache",
                                                "Industries extractives, \u00e9nergie, eau, gestion des d\u00e9chets et d\u00e9pollution",
                                                "Fabrication de denr\u00e9es alimentaires, de boissons et  de produits à base de tabac",
                                                "Cok\u00e9faction et raffinage",
                                                "Fabrication d'\u00e9quipements \u00e9lectriques, \u00e9lectroniques, informatiques ; fabrication de machines",
                                                "Fabrication de mat\u00e9riels de transport",
                                                "Fabrication d'autres produits industriels",
                                                "Construction",
                                                "Commerce ; r\u00e9paration d'automobiles et de motocycles",
                                                "Transports et entreposage",
                                                "H\u00e9bergement et restauration",
                                                "Information et communication",
                                                "Activit\u00e9s financi\u00e8res et d'assurance",
                                                "Activit\u00e9s immobili\u00e8res",
                                                "Activit\u00e9s scientifiques et techniques ; services administratifs et de soutien",
                                                "Administration publique, enseignement, sant\u00e9 humaine et action sociale",
                                                "Autres activit\u00e9s de services"),
                             stringsAsFactors = FALSE)

# otex en clair
# recode(x, old = new)
exploit_vaches_otex_clair <- exploit_vaches_otex %>% 
  mutate(otex_libelle = recode(otefda_coef17,
                               "1516"="Grandes cultures",
                               "2829"="Maraîchage, horticulture",
                               "3500"="Viticulture",
                               "3900"="Fruits ou autres cultures permanentes",
                               "4500"="Bovins lait",
                               "4600"="Bovins viande",
                               "4700"="Bovins mixte",
                               "4800"="Ovins, caprins, autres herbivores",
                               "5074"="Porcs, volailles",
                               "6184"="Polyculture, polyélevage",
                               "9000"="Exploitations non classées",
                                .default = "autre"))
```